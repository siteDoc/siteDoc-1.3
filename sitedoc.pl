#!/usr/bin/perl -w

############################################################################
##
##  siteDoc -- Program to recursively parse HTML, JS and CSS files
##             Identifies and records usage of variables, classes, images etc.
## Copyright:  Mike Brockington  for  calcResult
##             All rights reserved. &copy; 09/10/2014
##
##             Inspired by JSDoc, see: http://jsdoc.sourceforge.net/
##             Some sections based on examples from the "PERL Cookbook" from O'Reilly
##             All bugs are my own work...
##
############################################################################
## Changelog:
## 18/01/2009 Modified to work with Apache on a remote Linux server. Still being run on Windows XP.
## 25/02/2010 Now treats other file types the same as HTML, including PHP, SHTML, JSP etc.
## 01/03/2010 Preamble added to output to give some detail of "local conditions"
## 04/03/2010 Changed system for full-file info pages to a linear system, so that second-pass parsing doesn't have to guess at the origin page.
## 18/05/2012 Temporary data storage strategy re-factored
## 26/06/2013 Version 1.3 begun, "Sighthill Version"
## 24/07/2014 Now running on Win7
## 24/09/2014 Line numbering reference added for JS functions
## 29/09/2014 List of HTML tags condensed into a single reference, rather than spread out throughout the program
## 08/10/2014 First entered on to GitHub


## ToDo:
## Handle CSS atribute selectors
## Handle HTML tag atributes?
## Handle CSS pseudo elements   :before  :after  listed in  @barePseudoElements
## Handle CSS pseudo classes   e.g. a:link       listed in  @barePseudoClasses


use File::Find;
use File::Basename;
use File::Copy;
use Cwd            qw( abs_path );
use File::Basename qw( dirname );
use List::Util     qw(first);
use IO::Handle     qw( );  # For flush

use strict;
use warnings;
use autodie;

# Need to ensure that any backslash characters are doubled up, otherwise they get treated as escape characters:
# use constant CONFIG_FILE_NAME         => "\\\\Ligier.drivers\\apache_Storage\\calcResult\\siteDoc-1.2\\sitedoc.config";

# The config file MUST live in the same folder as this file.
use constant CONFIG_FILE_NAME         => dirname(abs_path($0))."/sitedoc.config";
use constant APP_VERSION              => "1.3";


use constant SHRINK_LINK => "<a href=\"#\" onclick=\"shrinkList(this.parentNode);return false;\">Shrink</a>&nbsp; this list <a href=\"#\" onclick=\"expandList(this.parentNode);return false;\">Expand</a>";

############################################################################

$0 = "SiteDoc";
print "Output from $0 ".APP_VERSION." running on Perl version $], $^O \n";
my $gblDateStamp = getNiceDate();
print "Started on $gblDateStamp\n";
print "Using config: ".CONFIG_FILE_NAME."\n\n";

## Next three lines set up auto-flush, useful if an error occurs in an unfortunate place, otherwise the error code may not get printed to the debug log...
my $output_fh = select(STDOUT);
$| = 1;
select($output_fh);

############################################################################

my $gblFileSignature = "Datafile generated by $0 ".APP_VERSION." on $gblDateStamp\n";

my ($HTMLfileList, $CSSfileList, $JSfileList, $OtherFilesList);
my ($fileCounter, $folderCounter, $HTML_Counter, $CSS_Counter, $JS_Counter, $IMG_Counter) = ('0','0','0','0','0','0');

my $gblCurrentOutput = "";

my (@HREF_List, @MAILTO_List, @CSS_List, @JS_List, @IMG_List, @FORM_List, @TAG_CLASS_List, @TAG_ID_List);  # HTML (or similar) file contents
my (@FUNCTION_List_Trad, @FUNCTION_List_Anon, @FUNCTION_List_Method, @FUNCTION_List_Closure);             #  JavaScript file contents
my (@CLASS_List, @ID_List, @TAG_List, @URL_List);                                                        #   CSS file contents
my @gblFileArray;                                   #         List of all files, needed for back-reference during later stages

# Second Pass Storage Variables:
my (@gblCLASSlist, @gblTAGlist, @gblIDlist, @gblIMGlist, @gblHREFlist, @gblJSFILElist, @gblFORMlist, @gblCSSFILElist);
my (@gblFUNClist, @gblANONlist, @gblMETHlist);
my (@gblResourceList);

my %configValues;
my $output;

# General Vars:
my @bareTagNames       = qw(H1 H2 H3 H4 H5 H6 BODY TABLE TBODY TR TD TH TFOOT THEAD LABEL P A IMG PICTURE SOURCE FORM FIELDSET DIV SPAN INPUT BUTTON TEXTAREA SELECT OPTION OPTGROUP PROGRESS NAV ABBR LI UL OL DL DT DD CITE ACRONYM BLOCKQUOTE Q QUOTE CAPTION HR CODE EM STRONG FRAME IFRAME HTML \\\* MAP);
my @barePseudoClasses  = qw(link visited hover active focus target enabled disabled checked indeterminate root first-child last-child nth-child(N) nth-of-type(N) first-of-type last-of-type nth-last-of-type(N) nth-last-child(N) only-of-type not(S) empty first-letter first-line lang selection);
my @barePseudoElements = qw(before after);

############################################################################
# Parse the config file:
readConfig();

my $gblLogLevel = $configValues{"logLevel"};
if ($gblLogLevel < 0)
{
    $gblLogLevel = 1;
}
if ($gblLogLevel > 100)
{
    $gblLogLevel = 100;
}
$gblLogLevel = $gblLogLevel - 1;


my $gblIndexFileSpec      = $configValues{"reportBase"}."/index.html";
my $gblMainDatFolder      = $configValues{"dataStore"}."/dats";
my $gblSecondaryDatFolder = $configValues{"dataStore"}."/resources";

my $gblFileListSpec     = $gblSecondaryDatFolder."/files.dat";
my $gblResourceListSpec = $gblSecondaryDatFolder."/resources.dat";

#  siteRoot = \\Ligier.drivers\apache_Storage\calcResult\www-calcResult-com-dev
# dataStore = \\Ligier.drivers\apache_Storage\calcResult\siteDoc-1.2\data
#reportBase = \\Ligier.drivers\apache_Storage\calcResult\sitedoc
my $dataStoreEscaped  = $gblMainDatFolder;
   $dataStoreEscaped  =~ s/\\/\\\\/gi;     #   Replace backslash with double-backslash, so that it is 'escaped' for the next RegExp
my $reportBaseEscaped = $configValues{"reportBase"};
   $reportBaseEscaped =~ s/\\/\\\\/gi;     #   Replace backslash with double-backslash, so that it is 'escaped' for the next RegExp

checkConfig();


# Walk the site:
displayMsg(100, "Documenting Site:".$configValues{"siteName"}."\n");
displayMsg(10000, "Logging messages greater than:$gblLogLevel.\n");
displayMsg(90, "Parsing:".$configValues{"siteRoot"}."\n");
displayMsg(80, "\$configValues{\"ignoreFilePatterns\"} = \"".$configValues{"ignoreFilePatterns"}."\"\n");
displayMsg(80, "\$configValues{\"ignoreFolderPatterns\"} = \"".$configValues{"ignoreFolderPatterns"}."\"\n");
displayMsg(100, "\n");


open (INDEX_FILE, ">$gblIndexFileSpec")    || die "Fatal Error: Unable to write to: '".$gblIndexFileSpec."': $!\n";
open (MAIN_DATA_FILE, ">$gblFileListSpec") || die "Fatal Error: Unable to write to: '".$gblFileListSpec."': $!\n";

## Write the 'Global File List' to disc:
displayMsg(40, "Writing file names to: $gblFileListSpec\n");
displayMsg(40, "Writing data summary to: $gblIndexFileSpec\n");

print MAIN_DATA_FILE $gblFileSignature;


my $tempVar = getHTML_Top("SiteDoc Documentation for ".$configValues{"siteName"});
print INDEX_FILE $tempVar;
print INDEX_FILE "\n".SHRINK_LINK;
print INDEX_FILE "\n<UL>";

## Start processing:
find(\&processSourceFiles, $configValues{"siteRoot"});

close MAIN_DATA_FILE;
# close RESOURCE_FILE;


# Finished the initial Parsing

$output  = "\nIndexing Statistics\n";
$output .=   "- - - - - - - - - -\n";
$output .= $fileCounter." files processed:\n    ";
$output .= $HTML_Counter." HTML files,\n    ";
$output .= $CSS_Counter." CSS files,\n    ";
$output .= $JS_Counter." JS files,\n    ";
$output .= $IMG_Counter." Images,\n";
$output .= "and $folderCounter folders.\n\n";
displayMsg(1000, $output);
$output = "";

showSymbols();

# Condense the contents of all .DAT  files:
displayMsg(50, "\nAbout to preProcessData() ...\n");
find(\&preProcessData, $gblMainDatFolder);
finaliseInternalData();

# Create the content of the Default documentation page:
displayMsg(50, "About to processData() based on: ".$gblMainDatFolder."\n");
find(\&processData, $gblMainDatFolder);

print INDEX_FILE "\n</UL>";

## Start the Second Pass:
print INDEX_FILE "\n<H2>Component Usage Data</H2>";
displayMsg(50, "Re-Parsing, re-reading DAT files \n");
find(\&reProcessData, $gblMainDatFolder);

sortSecondPassData();
writeSecondPassIndexBlock();

print INDEX_FILE "\n</div>";
print INDEX_FILE &getHTML_Footer("true");
close INDEX_FILE;

# End of main program flow #



#################################
# Start of Sub-routine section: #
#################################

# Parse the data files created during the first pass:
sub processData{
    my $thisFile     = $File::Find::name;
    #my $thisFileName = getFileName($thisFile);

    if(-d)
    {
        displayMsg(70, "Parsing contents of data Folder: ".$thisFile."\n");

        # ToDo: Flesh this out
        # Possibly produce a simple contents listing?

        ## Count the number of files in this folder.
        ## May include non-files depending on file system
        opendir my $dh, $thisFile or displayMsg(99, "ERROR processData(): Can't opendir '$thisFile': $!");
        my $fileCount = scalar grep { -f "$thisFile/$_" } readdir $dh;
        closedir $dh or displayMsg(50, "WARNING processData(): Can't closedir: $!");
        displayMsg(55, "  Folder contains: ".$fileCount." files\n");
    }else{
        unless (open CURRENTFILE, $thisFile)
        {
            displayMsg(90, "Unable to read from $thisFile: $!\n");
            return;
        }
        if (checkDatFileFormat($thisFile) )
        {
            displayMsg(60, "Internal Data File: ".$thisFile."\n");
            writeInternalData($thisFile);
        }else{
            displayMsg(999, "ERROR 200166: Unable to handle internal data file: ".$thisFile."\n");
        }
        close CURRENTFILE;
    }
}
############################################################################
# Parse the data files created during the first pass:
sub preProcessData{
    my $thisFile     = $File::Find::name;
    #my $thisFileName = getFileName($thisFile);

    if(-d)
    {
        displayMsg(70, "Parsing contents of data Folder: ".$thisFile."\n");

        # ToDo: Flesh this out
        # Possibly produce a simple contents listing?

        ## Count the number of files in this folder.
        ## May include non-files depending on file system
        opendir my $dh, $thisFile or displayMsg(99, "ERROR processData(): Can't opendir '$thisFile': $!");
        my $fileCount = scalar grep { -f "$thisFile/$_" } readdir $dh;
        closedir $dh or displayMsg(50, "WARNING processData(): Can't closedir: $!");
        displayMsg(55, "  Folder contains: ".$fileCount." files\n");
    }else{
        unless (open CURRENTFILE, $thisFile)
        {
            displayMsg(999, "Unable to read from $thisFile: $!\n");
            return;
        }
        if (checkDatFileFormat($thisFile) )
        {
            displayMsg(60, "Internal Data File: ".$thisFile."\n");
            indexInternalData($thisFile);
        }else{
            displayMsg(999, "ERROR 20F1CC: Unable to handle internal data file: ".$thisFile."\n");
        }
        close CURRENTFILE;
    }
}
############################################################################
# Re-Parse the data files:
sub reProcessData{
    my $thisFile = $File::Find::name;
    #my $thisFileName = getFileName($thisFile);

    if(-d)
    {
        displayMsg(70, "Parsing contents of data Folder: ".$thisFile."\n");

        # ToDo: Flesh this out
        # Possibly produce a simple contents listing?

        ## Count the number of files in this folder.
        ## May include non-files depending on file system
        opendir my $dh, $thisFile or displayMsg(99, "ERROR processData(): Can't opendir '$thisFile': $!");
        my $fileCount = scalar grep { -f "$thisFile/$_" } readdir $dh;
        closedir $dh or displayMsg(50, "WARNING processData(): Can't closedir: $!");
        displayMsg(55, "  Folder contains: ".$fileCount." files\n");
    }else{
        unless (open CURRENTFILE, $thisFile)
        {
            displayMsg(999, "20F141: Second Pass: Unable to read from $thisFile: $!\n");
            return;
        }
        if (checkDatFileFormat($thisFile) )
        {
            displayMsg(100, "Second Pass: Internal Data File: ".$thisFile."\n");
            getSecondPassData($thisFile);
        }else{
            displayMsg(999, "ERROR 20F142: Second Pass: Unable to handle internal data file: ".$thisFile."\n");
        }
        close CURRENTFILE;
    }
}

############################################################################
# Remove duplicates:
sub sortSecondPassData{
   @gblCLASSlist  = deDupeArray(@gblCLASSlist);
   @gblTAGlist    = deDupeArray(@gblTAGlist);
   @gblIDlist     = deDupeArray(@gblIDlist);
   @gblHREFlist   = deDupeArray(@gblHREFlist);
   @gblIMGlist    = deDupeArray(@gblIMGlist);
   @gblJSFILElist = deDupeArray(@gblJSFILElist);
   @gblFORMlist   = deDupeArray(@gblFORMlist);
   @gblCSSFILElist= deDupeArray(@gblCSSFILElist);
   @gblFUNClist   = deDupeArray(@gblFUNClist);
   @gblANONlist   = deDupeArray(@gblANONlist);
   @gblMETHlist   = deDupeArray(@gblMETHlist);
}
############################################################################
sub buildDataReport{
    my $thisObject  = shift||'';
    my $titlePrefix = shift||'';
    my $lineNumber  = shift||0;

    # MJB ToDo:  what do we do with $lineNumber ??

    displayMsg(10, "sub buildDataReport ($thisObject)\n");
    my $thisLink = $thisObject;
    my $gblTruncatedFileCount;

# Next block MUST match with: sub getDataLink
    if($thisLink eq "*")
    {
        $thisLink = "STAR";           # A 'raw' asterisk causes all sorts of problems
    }
    $thisLink =~ s/[()]//g;           # Remove any round brackets
    $thisLink =~ s/[^a-zA-Z0-9]/_/g;  # Replace non-alpha chars with underscores
# as far as this point

    if(length($thisLink) > $configValues{"maxFileNameLength"} )
    {
        displayMsg(90, "WARNING 20F18F: Having to truncate: $thisLink, original length: (".length($thisLink).")\n");
        $gblTruncatedFileCount++;
        my $requiredLinkLength = ($configValues{"maxFileNameLength"} - length($gblTruncatedFileCount));
        my $tempLink = substr($thisLink, 0, $requiredLinkLength);
        displayMsg(30, "INFO: \$thisLink truncated to new length: ".length($tempLink)."\n");
        $thisLink = $tempLink.$gblTruncatedFileCount;
    }
    # ToDo: implement a routine to check the _total_ length of the path, and truncate as necessary - the above only deals with current file.

    my $outFileSpec = $configValues{"reportBase"}."/lists/";
    displayMsg(20, "buildDataReport: \$outFileSpec: $outFileSpec \n");
    checkReportDataPath($outFileSpec);
    $outFileSpec = $outFileSpec.$thisLink;

    ## MJB Why the hell do we _NOT_ need to escape the dot on the next line??
    unless (open OUTFILE_DAT, ">$outFileSpec.html")
    {
        #ToDo: Make a second attempt?
        displayMsg(999, "ERROR 20F16F: Unable to write to $outFileSpec\.html: $!\n");
        return;
    }
    print OUTFILE_DAT &getListReport_Top( mapReportDataPathToPageTitle($thisObject, $titlePrefix) );

    print OUTFILE_DAT &buildDataReportDetail($thisObject);

    print OUTFILE_DAT &getHTML_Footer();
    close OUTFILE_DAT;
}
############################################################################
sub writeSecondPassIndexBlock{
    my $thisList = "";
    my $thisLink = "";
    my $thisLine = 0;


    foreach (@gblTAGlist)
    {
        $thisLink = getDataLink($_, "lists");
        if($thisLink)
        {
            $thisList .= "\n<li>$thisLink</li>";
            buildDataReport($_, "CSS Tag Selector");
        }
    }
    print INDEX_FILE &buildPageBlockList("CSS Tag Selector Usage List", $thisList);
    $thisList = "";

    foreach (@gblIMGlist)
    {
        $thisLink = getDataLink($_, "lists");
        if($thisLink)
        {
            $thisList .= "\n<li>$thisLink</li>";
            buildDataReport($_, "Image");
        }
    }
    print INDEX_FILE &buildPageBlockList("&lt;Image&gt; Usage List", $thisList);
    $thisList = "";

    foreach (@gblFORMlist)
    {
        $thisLink = getDataLink($_, "lists");
        if($thisLink)
        {
            $thisList .= "\n<li>$thisLink</li>";
            buildDataReport($_, "FORM action");
        }
    }
    print INDEX_FILE &buildPageBlockList("&lt;Form&gt; Usage List", $thisList);
    $thisList = "";

    foreach (@gblCSSFILElist)
    {
        $thisLink = getDataLink($_, "files/CSS");
        if($thisLink)
        {
            $thisList .= "\n<li>$thisLink</li>";
            buildDataReport($_, "CSS File");
        }
    }
    print INDEX_FILE &buildPageBlockList("CSS File Usage List", $thisList);
    $thisList = "";

    foreach (@gblCLASSlist)
    {
        $thisLink = getDataLink($_, "lists");
        if($thisLink)
        {
            $thisList .= "\n<li>$thisLink</li>";
            buildDataReport($_, "CSS Classes");
        }
    }
    print INDEX_FILE &buildPageBlockList("CSS Class Usage List", $thisList);
    $thisList = "";

    foreach (@gblIDlist)
    {
        $thisLink = getDataLink($_, "lists");
        if($thisLink)
        {
            $thisList .= "\n<li>$thisLink</li>";
            buildDataReport($_, "CSS ID");
        }
    }
    print INDEX_FILE &buildPageBlockList("CSS ID Usage List", $thisList);
    $thisList = "";

    foreach (@gblHREFlist)
    {
        $thisLink = getDataLink($_, "lists");
        if($thisLink)
        {
            $thisList .= "\n<li>$thisLink</li>";
            buildDataReport($_, "Hyperlinks");
        }
    }
    print INDEX_FILE &buildPageBlockList("HREF Usage List", $thisList);
    $thisList = "";

    foreach (@gblJSFILElist)
    {
        $thisLink = getDataLink($_, "files/JS");
        if($thisLink)
        {
            $thisList .= "\n<li>$thisLink</li>";
            buildDataReport($_, "JavaScript Files");
        }
    }
    print INDEX_FILE &buildPageBlockList("JS File Usage List", $thisList);
    $thisList = "";

    foreach (@gblFUNClist)
    {
        $thisLink = getDataLink($_, "lists");
        $thisLine = getDataLine($_);
        if($thisLink)
        {
            $thisList .= "\n<li>$thisLink</li>";
            buildDataReport($_, "JavaScript Named Functions", $thisLine);
        }
    }
    print INDEX_FILE &buildPageBlockList("JS Named Function Usage List", $thisList);
    $thisList = "";

    foreach (@gblANONlist)
    {
        $thisLink = getDataLink($_, "lists");
        if($thisLink)
        {
            $thisList .= "\n<li>$thisLink</li>";
            buildDataReport($_, "JavaScript Anonymous Functions");
        }
    }
    print INDEX_FILE &buildPageBlockList("JS 'Anonymous Function' Usage List", $thisList);
    $thisList = "";

    foreach (@gblMETHlist)
    {
        $thisLink = getDataLink($_, "lists");
        if($thisLink)
        {
            $thisList .= "\n<li>$thisLink</li>";
            buildDataReport($_, "JavaScript Method");
        }
    }
    print INDEX_FILE &buildPageBlockList("JS 'Method' Usage List", $thisList);
    displayMsg(70, "Sub Complete: writeSecondPassIndexBlock()\n");

}

############################################################################
# Parse an individual file:
sub processSourceFiles{
    my $thisFile     = $File::Find::name;
    my $thisFileName = getFileName($thisFile);             # ToDo Find a way to do this with native code
    my $thisFileExt  = getFileExtension($thisFileName);   #  ToDo Find a way to do this with native code
    my $thisBareFileID;
    my $thisFolderLocation;

    if(-d)
    {
        if($thisFile =~ m/$configValues{"ignoreFolderPatterns"}/i )
        {
            displayMsg(200, "Folder Ignored: \"$thisFile\"\n");
        }else{
            $folderCounter++;
            push(@gblFileArray, $thisFile);
            $thisBareFileID = @gblFileArray;
            displayMsg(29, "~ Directory Found: \"$thisFile\"\n");
            print INDEX_FILE "\n<li>".getFirstPassFolderLink($thisBareFileID, $thisFile)."</li>";
            recordThisFile($thisBareFileID, $thisFile);
            ## MJB ToDo: Write some info about this folder, save page in /folders/fileRef.html
            print "processFolder:".processFolder($thisFile)." files \n";
        }
    }else{
        displayMsg(2, "\nSource File Ext: \"$thisFileExt\"\n");
        if($thisFile =~ m/$configValues{"ignoreFilePatterns"}/i )
        {
            displayMsg(25, "+File Ignored:     \"$thisFile\"\n");
        }else{
            if ($thisFileExt =~ m/shtml\z|html\z|htm\z|js\z|css\z|asp\z|jsp\z|php\z|aspx\z|jpg\z|jpeg\z|svg\z|png\z|gif\z|bmp\z/i )
            {
                $fileCounter++;
                push(@gblFileArray, $thisFile);
                $thisBareFileID = @gblFileArray;
                displayMsg(10, "processSourceFiles: \$thisFile = \"$thisFile\"\n");
                unless (open CURRENTFILE, $thisFile)
                {
                    displayMsg(90, "Unable to read from \"$thisFile\": $!\n");
                    return;
                }
                if ($thisFileExt =~ m/html\z|htm\z/i )
                {
                    displayMsg(100, "HTML File: ".$thisFile."\n");
                    $thisFolderLocation = "HTML";
                    print INDEX_FILE "\n<li>".getFirstPassDoubleFileLink($thisBareFileID, $thisFile, $thisFolderLocation)."</li>";
                    recordThisFile($thisBareFileID, $thisFile);
                    processHTML();
                    writePageData_HTML($thisBareFileID);
                }

                if ($thisFileExt eq "shtml" )
                {
                    displayMsg(100, "Server-Side (shtml) File: ".$thisFile."\n");
                    $thisFolderLocation = "HTML";
                    print INDEX_FILE "\n<li>".getFirstPassDoubleFileLink($thisBareFileID, $thisFile, $thisFolderLocation)."</li>";
                    recordThisFile($thisBareFileID, $thisFile);
                    processSHTML();
                    writePageData_HTML($thisBareFileID);   # ToDo: change this line to a more-specific routine
                }

                if ($thisFileExt eq "asp" || $thisFileExt eq "aspx" )
                {
                    displayMsg(100, "Server-Side (ASP) File: ".$thisFile."\n");
                    $thisFolderLocation = "HTML";
                    print INDEX_FILE "\n<li>".getFirstPassDoubleFileLink($thisBareFileID, $thisFile, $thisFolderLocation)."</li>";
                    recordThisFile($thisBareFileID, $thisFile);
                    processASP();
                    writePageData_HTML($thisBareFileID);   # ToDo: change this line to a more-specific routine
                }

                if ($thisFileExt eq "jsp")
                {
                    displayMsg(100, "Server-Side (JSP) File: ".$thisFile."\n");
                    $thisFolderLocation = "HTML";
                    print INDEX_FILE "\n<li>".getFirstPassDoubleFileLink($thisBareFileID, $thisFile, $thisFolderLocation)."</li>";
                    recordThisFile($thisBareFileID, $thisFile);
                    processJSP();
                    writePageData_HTML($thisBareFileID);   # ToDo: change this line to a more-specific routine
                }

                if ($thisFileExt eq "php" )
                {
                    displayMsg(100, "Server-Side (PHP) File: ".$thisFile."\n");
                    $thisFolderLocation = "HTML";
                    print INDEX_FILE "\n<li>".getFirstPassDoubleFileLink($thisBareFileID, $thisFile, $thisFolderLocation)."</li>";
                    recordThisFile($thisBareFileID, $thisFile);
                    processPHP();
                    writePageData_HTML($thisBareFileID);   # ToDo: change this line to a more-specific routine
                }

                if ($thisFileExt eq "js" )
                {
                    displayMsg(100, "JS File:    ".$thisFile."\n");
                    $thisFolderLocation = "JS";
                    print INDEX_FILE "\n<li>".getFirstPassDoubleFileLink($thisBareFileID, $thisFile, $thisFolderLocation)."</li>";
                    recordThisFile($thisBareFileID, $thisFile);
                    processJavascript();
                    writePageData_JS($thisBareFileID);
                }

                if ($thisFileExt eq "css" )
                {
                    displayMsg(100, "CSS File:   ".$thisFile."\n");
                    $thisFolderLocation = "CSS";
                    print INDEX_FILE "\n<li>".getFirstPassDoubleFileLink($thisBareFileID, $thisFile, $thisFolderLocation)."</li>";
                    recordThisFile($thisBareFileID, $thisFile);
                    processCSS();
                    writePageData_CSS($thisBareFileID);
                }

                if ($thisFileExt =~ m/jpg\z|jpeg\z|svg\z|png\z|gif\z|bmp|ico\z/i )
                {
                    displayMsg(100, uc($thisFileExt)." File:  ".$thisFile."\n");
                    $thisFolderLocation = "IMG";
                    print INDEX_FILE "\n<li>".getFirstPassDoubleFileImageLink($thisBareFileID, $thisFile, $thisFolderLocation, processImage($thisFile) )."</li>";
                    recordThisFile($thisBareFileID, $thisFile);
                    $IMG_Counter++;
                        # No need to read binary data, so just ignore the contents of this file:
                        # print "processImage:".processImage($thisFile)."bytes \n";
                        # writePageData_Image();
                }
                close CURRENTFILE;
                INDEX_FILE->flush();
            }else{
                displayMsg(50, "-File Not Handled: ".$thisFile."\n");
            }
        }
        displayMsg(3, "Files Total: ".@gblFileArray."\n");
    }
}

############################################################################
sub processHREF{
    my $thisExtract = $_;
    my $linkText;
    while($thisExtract =~ /href/i)
    {
        $linkText = $thisExtract;
        $linkText =~ /href\s*=\s*('|")(.+?)('|")/;   # " The double-quote chars in this regex confuses UltraEdits syntax highlighting, but the one at the start of this comment sorts things out
        if($2)
        {
            push(@HREF_List, $2."\n");
            displayMsg(33, "a"); # Progress indicator character
        }
        $thisExtract =~ s/href\s*/ /i;  ## Keep this match simple, in case the RegExp above did not provide a $2 match
    }
}
############################################################################
sub processMAILTO{
    my $thisExtract = $_;
    my $linkText;
    while($thisExtract =~ /mailto/i)
    {
        $linkText = $thisExtract;
        $linkText =~ /mailto\s*:\s*(.+?)\s/;   # " The double-quote chars in this regex confuses UltraEdits syntax highlighting, but the one at the start of this comment sorts things out
        if($2)
        {
            push(@MAILTO_List, $2."\n");
            displayMsg(33, "a"); # Progress indicator character
        }
        $thisExtract =~ s/mailto\s*/ /i;  ## Keep this match simple, in case the RegExp above did not provide a $2 match
    }
}
############################################################################
sub processLink{
    my $thisExtract = $_;
    my $linkText;
    while($thisExtract =~ /<link.*href/i)
    {
        $thisExtract =~ s/<link.*href/ /i;
        $linkText = $thisExtract;
        $linkText =~ /(\"|\')(.*?)(\"|\')/;
        push(@CSS_List, $2."\n");
        displayMsg(33, "l"); # Progress indicator character
    }
}
############################################################################
sub processScript{
    my $thisExtract = $_;
    my $linkText;
    while($thisExtract =~ /<script.*src/i)
    {
        $thisExtract =~ s/<script.*src/ /i;
        $linkText = $thisExtract;
        $linkText =~ /(\"|\')(.*?)(\"|\')/;
        push(@JS_List, $2."\n");
        displayMsg(33, "j"); # Progress indicator character
    }
}
############################################################################
sub processIMG{
    my $thisExtract = $_;
    my $linkText;
    while($thisExtract =~ /<img.*src/i)
    {
        $thisExtract =~ s/<img.*src/ /i;
        $linkText = $thisExtract;
        $linkText =~ /(\"|\')(.*?)(\"|\')/;
        push(@IMG_List, $2."\n");
        displayMsg(33, "~"); # Progress indicator character
    }
}
############################################################################
sub processFormAction{
    my $thisExtract = $_;
    my $linkText;
    while($thisExtract =~ /<form.*action/i)
    {
        $thisExtract =~ s/<form.*action/ /i;
        $linkText = $thisExtract;
        $linkText =~ /(\"|\')(.*?)(\"|\')/;
        if($2)
        {
            push(@FORM_List, $2."\n");
            displayMsg(33, "f"); # Progress indicator character
        }
    }
}
############################################################################
sub processFunctionName{
    my $thisExtract = shift||'';
    my $lineNumber  = shift||0;
    my $linkText;
    while($thisExtract =~ /\bfunction/i)
    {
        $linkText = $thisExtract;
        # Search for a function name:
        $linkText =~ /(function\s*\w+\s*\([\w ,]*\))/i;
        if($1)
        {
            displayMsg(33, "/"); # Progress indicator character
            # displayMsg(33, "\nprocessFunctionName, line:$lineNumber: \$1: ".$1."\n");
            # push(@FUNCTION_List_Trad, $1."()");
            push(@FUNCTION_List_Trad, $1." Line:".$lineNumber);
            $thisExtract =~ s/function/ /i;
        }else{
            displayMsg(25, "WARNING! processFunctionName, line:$lineNumber: no match made: \"".$thisExtract."\"\n");
            # Need to trim the string, or we get an infinite loop:
            $thisExtract =~ s/.//;  # remove first character
        }
    }
}
############################################################################
sub processAnonMethod{
    my $thisExtract = shift||'';
    my $lineNumber  = shift||0;
    my $linkText;
    while($thisExtract =~ /\S+\s*:\s*function\s*\(/i)
    {
        $linkText = $thisExtract;
        $linkText =~ /(\S+)\s*:\s*function\s*\(/;
        if($1)
        {
            displayMsg(33, "-"); # Progress indicator character
            my $safeString = $1; #
            push(@FUNCTION_List_Method, $safeString." Line:".$lineNumber);
            $thisExtract =~ s/\S+\s*:\s*function/ /i;
        }else{
            displayMsg(999, "processAnonMethod, line:$lineNumber: no match made: ".$thisExtract."\n");
            # Need to trim the string, or we get an infinite loop:
            $thisExtract =~ s/.//;  # remove first character
        }
    }
}
############################################################################
sub processObjectMethod{
    my $thisExtract = shift||'';
    my $lineNumber  = shift||0;
    my $linkText;
    while($thisExtract =~ /\s\S+?\s*=\s*function\s*?\(/i)
    {
        $linkText = $thisExtract;
        $linkText =~ /\s(\S+?)\s*=\s*function\s*?\(/;
        if($1)
        {
            displayMsg(33, "|"); # Progress indicator character
            my $safeString = $1; #
            $safeString .= "()\n";
            push(@FUNCTION_List_Method, $safeString." Line:".$lineNumber);
            $thisExtract =~ s/\s\S+?\s*=\s*function\s*?\(/ /i;
        }else{
            displayMsg(999, "processObjectMethod, line:$lineNumber: no match made: ".$thisExtract."\n");
            # Need to trim the string, or we get an infinite loop:
            $thisExtract =~ s/.//;  # remove first character
        }
    }
}
############################################################################
sub processNewAnonFunction{
    my $thisExtract = shift||'';
    my $lineNumber  = shift||0;
    my $linkText;
    while($thisExtract =~ /\s\S+?\s*=\s*new\s+function(\s*)/i)
    {
        $linkText = $thisExtract;
        $linkText =~ /\s(\S+?)\s*=\s*new\s+function(\s*)/;
        if($1)
        {
            displayMsg(33, "\\"); # Progress indicator character
            push(@FUNCTION_List_Anon, $1." Line:".$lineNumber);
            $thisExtract =~ s/\s\S+?\s*=\s*new\s+function(\s*)/ /i;
        }else{
            displayMsg(999, "processNewAnonFunction, line:$lineNumber: no match made: ".$thisExtract."\n");
            # Need to trim the string, or we get an infinite loop:
            $thisExtract =~ s/.//;  # remove first character
        }
    }
}
############################################################################
# Closures etc are just a specific type of anonymous function
sub processClosureFunction{
    my $thisExtract = shift||'';
    my $lineNumber  = shift||0;
    my $linkText;
    while($thisExtract =~ /function/i)
    {
        $linkText = $thisExtract;
        $linkText =~ /(function\s*\(\s*\))/;
        if($1)
        {
            displayMsg(33, "¬"); # Progress indicator character
            # MJB ToDo: not much point recording the "name" of an anonymous function, so need to do something better than  $1  on the next line:
            # MJB would it be useful to have a unique reference? Is it possible to keep track of multiple references - do we even get the same function listed more than once?
            push(@FUNCTION_List_Closure, $1." Line:".$lineNumber);
            $thisExtract =~ s/function\s*\(\s*\)/ /i;
        }else{
            displayMsg(999, "processClosureFunction, line:$lineNumber: no match made: ".$thisExtract."\n");
            # Need to trim the string, or we get an infinite loop:
            $thisExtract =~ s/.//;  # remove first character
        }
    }
}
############################################################################
# anonymous functions:
sub processAnonFunction{
    my $thisExtract = shift||'';
    my $lineNumber  = shift||0;
    my $linkText;
    while($thisExtract =~ /function/i)
    {
        $linkText = $thisExtract;
        $linkText =~ /(\bfunction\w+\([\W, ]\))/;
        if($1)
        {
            displayMsg(33, "^"); # Progress indicator character
            # MJB ToDo: not much point recording the "name" of an anonymous function, so need to do something better than  $1  on the next line:
            # MJB would it be useful to have a unique reference? Is it possible to keep track of multiple references - do we even get the same function listed more than once?
            push(@FUNCTION_List_Anon, $1." Line:".$lineNumber);
            $thisExtract =~ s/function\w+\([\W, ]\)/ /i;
        }else{
            displayMsg(999, "processAnonFunction, line:$lineNumber: no match made: ".$thisExtract."\n");
            # Need to trim the string, or we get an infinite loop:
            $thisExtract =~ s/.//;  # remove first character
        }
    }
}
############################################################################
# Process a line of CSS, which may contain more than one rule, and/or more than one HTML tag
sub processTAG_css{
    my $thisExtract = $_;
       $thisExtract =~ s/\s+$//;               #  Remove a trailing newline/whitespace char, if any exists
    my $tempVar = "";
    my $localTagList = '\b' . join('\b|\b', @bareTagNames) . '\b';
    my $bareTagList  = join('|', @bareTagNames);

    if((length ($thisExtract) > 1) || ($thisExtract =~ /[apq]/i))
    {
        # We need at least a couple of chars for this to be valid, so also need to explicitly check for the single-letter tags
    }else{
        return;
    }
    ## Look for an HTML tag, followed by an opening curly brace, dot, space, colon, hash-mark
    ## Need to try to ensure that _star_ does not match against CSS comments:   /* Comment */
    while($thisExtract =~ /($localTagList)/i)
    {
        if($1)
        {
            push(@TAG_List, $1);
            displayMsg(6, "TAG found: \"$1\"\n");
            ## Remove whatever we just found:
            if($1 ne "*")
            {
                # The star operator breaks the following regexp:
                $thisExtract =~ s/$1//i;
            }else{
                displayMsg(44, "STAR found: \"$1\"\n");
                # so just build the REGEX manually:
                $thisExtract =~ s/\*//i;
            }
            # Progress indicator character:
            displayMsg(33, "T");
        }else{
            # Look for TAGs embedded in other words, such as:  .narrowForm
            # If we just keep lopping off the first char, eventually this will become an erroneous match
            $thisExtract =~ /(\w+)/i;
            if($1){
                displayMsg(4, "Not an HTML tag:  \"$1\"\n");
                $thisExtract =~ s/$1//;
            }else{
                # Remove first char, so we don't get a loop:
                displayMsg(3, "processTAG_css: Removing first char\n");
                $thisExtract =~ s/.//;
            }
        }
    }
}
############################################################################
sub processCLASS{
    my $thisExtract = $_;
    my $linkText;
    while($thisExtract =~ /\.[a-zA-Z-_]/i)
    {
        $thisExtract =~ s/{.*?}/ /i;
        $linkText = $thisExtract;
        $linkText =~ /\.([a-zA-Z-_]+)/;
        if($1)
        {
            push(@CLASS_List, $1);
            $thisExtract =~ s/$1/ /i;
            displayMsg(33, "C"); # Progress indicator character
        }
        $thisExtract =~ s/{.*?}/ /i;
    }
}
############################################################################
sub processTagCLASS{
    my $thisExtract = $_;
    my $linkText;
    while($thisExtract =~ /class\s*=\s*('|")[_a-zA-Z0-9- ]+?('|")/i)   # "
    {
        $linkText = $thisExtract;
        $linkText =~ /class\s*=\s*('|")([_a-zA-Z0-9- ]+?)('|")/;       # "
        if($2)
        {
            # Need to check for a multiple-class definition: (space separated)
            my @classNames = split(" ", $2);
            foreach (@classNames)
            {
                push(@TAG_CLASS_List, $_);
                displayMsg(33, "."); # Progress indicator character
            }
            $thisExtract =~ s/class\s*=\s*('|")[_a-zA-Z0-9- ]+?('|")/ /i;    # "
        }
    }
}
############################################################################
sub processTAG_ID{
    my $thisExtract = $_;
    my $linkText;
    while($thisExtract =~ /ID\s*=\s*('|").+?('|")/i)                          # "
    {
        $linkText = $thisExtract;
        $linkText =~ /ID\s*=\s*('|")(.+?)('|")/;                              # "
        if($2)
        {
            push(@TAG_ID_List, $2."\n");
            $thisExtract =~ s/ID\s*=\s*('|").+?('|")/ /i;                     # "
            displayMsg(33, "#"); # Progress indicator character
        }
    }
}
############################################################################
sub processURLinCSS{
    my $thisExtract = $_;
    my $linkText;
    ## Start with a very simple match:
    while($thisExtract =~ /url/i)
    {
        $linkText = $thisExtract;
        $linkText =~ /url\s*\(['"]*([^'"\(\)]+)['"]*\)/;      # ' match the contents of a pair of brackets, following "url", excluding the brackets, and ignoring any quote marks
        if($1)
        {
            push(@URL_List, $1);
            $thisExtract =~ s/.*$1/ /i;      # Remove anything upto and including the matched text
            displayMsg(33, "U");             # Progress indicator character
        }
        $thisExtract =~ s/url/ /i;           # Remove first match, to prevent a possible infinite loop
    }
}
############################################################################
sub processID{
    my $thisExtract = $_;
    my $linkText;
    while($thisExtract =~ /^\#[a-zA-Z-_]/i)
    {
        $thisExtract =~ s/{.*?}/ /i;
        $linkText = $thisExtract;
        $linkText =~ /^\#([a-zA-Z-_]+)/;
        if($1)
        {
            push(@ID_List, $1);
            $thisExtract =~ s/$1/ /i;
            displayMsg(33, "I"); # Progress indicator character
        }
        $thisExtract =~ s/{.*?}/ /i;
    }
}
############################################################################
sub displayMsg{
    my $level = shift||'';
    my $msg   = shift||'';

    if($level > $gblLogLevel)
    {
        print $msg;
    }
}
############################################################################
sub showSymbols{
    print "\n --- Symbols --- \n";
    print " HTML \n";
    print "   l - link href \n";
    print "   a - a href \n";
    print "   ~ - img src \n";
    print "   @ - mailto \n";
    print "   j - script src \n";
    print "   f - form action \n";
    print "   . - Tag CLASS \n";
    print "   # - Tag ID \n";
    print " C.S.S. \n";
    print "   C - CLASS \n";
    print "   I - ID Selector \n";
    print "   T - TAG Selector \n";
    print "   U - Resource URL \n";
    print " JavaScript \n";
    print "   | - Object Method \n";
    print "   / - Standard Function \n";
    print "   \\ - Anonymous Function \n";
    print "   ¬ - Closure-style Function \n";
}
############################################################################
sub writeInternalData{
    my $thisFile = shift||'';
    my $thisType    = "";
    my $thisValue   = "";
    my $displayTxt  = "";

    my $HREFlist = "";
    my $CSS_FILElist = "";
    my $CLASSlist = "";
    my $URLlist = "";
    my $JS_FILElist = "";
    my $IMGlist = "";
    my $FORMlist = "";
    my $IDlist = "";
    my $TAGlist = "";
    my $FUNClist = "";
    my $ANONlist = "";
    my $METHlist = "";

    my $outFileSpec = mapShortDatFileName($thisFile);
    displayMsg(70, "writeInternalData: \$outFileSpec: $outFileSpec \n");
    checkFullReportPath($outFileSpec);

    unless (open HTML_FILE_OUT, ">$outFileSpec")
    {
        displayMsg(999, "ERROR 200167: Unable to write to file: $outFileSpec: $!\n");
        return;
    }
    unless (open DATFILE_IN, $thisFile)
    {
        displayMsg(999, "ERROR 20F1CE: Unable to read from file: $thisFile: $!\n");
        return;
    }

    print HTML_FILE_OUT &getReport_Top( mapDatFileNameToPageTitle($thisFile) );

    my @lines = <DATFILE_IN>;
    foreach (@lines)
    {
        if (index($_, $gblFileSignature) != -1)
        {
            displayMsg(10, "INFO: \$gblFileSignature found in file: $thisFile\n");
        }else{

            ($thisType, $thisValue) = split(":", $_, 2);
            if($thisValue && (length $thisValue > 2)) # Make sure that we have more than just a line-break
            {
                $displayTxt = $thisValue;              # Un-modified version of file name, for display purposes
                $thisValue =~ s/\s+$//;               #  Remove a trailing newline/whitespace char, if any exists
                $thisValue =~ s/[()]//g;             #   Remove any round brackets
                $thisValue =~ s/[^a-zA-Z0-9]/_/g;   #    Replace non-alpha chars with underscores

                # Why doesn't PERL have a CASE statement?:
                if($thisType eq "IMG")
                    { $IMGlist .= "\n<li>".getIMGLink($thisValue, $displayTxt)."</li>"; }
                if($thisType eq "HREF")
                    { $HREFlist .= "\n<li>".getReportHREFLink($thisValue, $displayTxt)."</li>"; }
                if($thisType eq "JS-FILE")
                    { $JS_FILElist .= "\n<li>".getReportJSFILELink($thisValue, $displayTxt)."</li>"; }
                if($thisType eq "FORM")
                    { $FORMlist .= "\n<li>".getReportFORMFLink($thisValue, $displayTxt)."</li>"; }
                if($thisType eq "CSS-FILE")
                    { $CSS_FILElist .= "\n<li>".getReportCSSFILELink($thisValue, $displayTxt)."</li>"; }
                if($thisType eq "CLASS")
                    { $CLASSlist .= "\n<li>".getNonFileLink($thisValue, $displayTxt, "css/CLASS")."</li>"; }
                if($thisType eq "URL")
                    { $URLlist .= "\n<li>".getReportURLLink($displayTxt)."</li>"; }
                if($thisType eq "ID")
                    { $IDlist .= "\n<li>".getNonFileLink($thisValue, $displayTxt, "css/ID")."</li>"; }
                if($thisType eq "TAG")
                    { $TAGlist .= "\n<li>".getNonFileLink($thisValue, $displayTxt, "TAG")."</li>"; }
                if($thisType eq "FUNC")
                    { $FUNClist .= "\n<li>".getNonFileLink($thisValue, $displayTxt, "js/FUNC")."</li>"; }
                if($thisType eq "ANON")
                    { $ANONlist .= "\n<li>".getNonFileLink($thisValue, $displayTxt, "js/ANON")."</li>"; }
                if($thisType eq "METH")
                    { $METHlist .= "\n<li>".getNonFileLink($thisValue, $displayTxt, "js/METH")."</li>"; }
            }
        }
    }
    print HTML_FILE_OUT &buildPageBlockList("HREF Links", $HREFlist);
    print HTML_FILE_OUT &buildPageBlockList("&lt;FORM&gt; Action List", $FORMlist);
    print HTML_FILE_OUT &buildPageBlockList("&lt;IMG&gt; Source List", $IMGlist);
    print HTML_FILE_OUT &buildPageBlockList("Linked CSS Files", $CSS_FILElist);
    print HTML_FILE_OUT &buildPageBlockList("Linked JS Files", $JS_FILElist);

    print HTML_FILE_OUT &buildPageBlockList("Classes's listed in CSS", $CLASSlist);
    print HTML_FILE_OUT &buildPageBlockList("ID's listed in CSS", $IDlist);
    print HTML_FILE_OUT &buildPageBlockList("URL's listed in CSS", $URLlist);
    print HTML_FILE_OUT &buildPageBlockList("HTML TAGs listed in CSS", $TAGlist);

    print HTML_FILE_OUT &buildPageBlockList("JavaScript Functions List", $FUNClist);
    print HTML_FILE_OUT &buildPageBlockList("JavaScript Anonymous Functions List", $ANONlist);
    print HTML_FILE_OUT &buildPageBlockList("JavaScript Object-Methods List", $METHlist);

    print HTML_FILE_OUT &getHTML_Footer();
    close HTML_FILE_OUT;
    close DATFILE_IN;
}
############################################################################
sub buildPageBlockList{
    my $thisTitle = shift||'';
    my $thisList  = shift||'';
    my $strOutput = "\n<div class=\"pageBlock\"><H3>".$thisTitle."</H3>";
    if(length $thisList > 2) # Make sure that we have more than just a line-break
    {
        $strOutput .= "\n".SHRINK_LINK;
        $strOutput .= "\n<UL>".$thisList."</UL>";
    }else{
        $strOutput .= "\n<p><i>None</i></p>";
    }
    $strOutput .= "\n</div>";

    return $strOutput;
}
############################################################################
sub processFolder{
    my $thisDir = shift || '.';

    # ToDo: Flesh this out
    # Possibly produce a simple contents listing?

    ## Count the number of files in this folder.
    ## May include non-files depending on file system
    ## opendir my $dh, $thisDir or die "Can't opendir '$thisDir': $!";
    opendir my $dh, $thisDir or displayMsg(99, "ERROR processFolder(): Can't opendir '$thisDir': $!");
    my $fileCount = scalar grep { -f "$thisDir/$_" } readdir $dh;
    ## closedir $dh or die "Can't closedir: $!";
    closedir $dh or displayMsg(50, "WARNING processFolder(): Can't closedir: $!");

    my $fileList = getListOfFilesAsHTML($thisDir);
    ## MJB ToDo: send this block of HTML somewhere useful:
    # print $fileList."\n";

    return $fileCount;
}
############################################################################
sub processASP{
    # ToDo: create this sub as a customised version of processHTML()
    return processHTML();
}

############################################################################
sub processJSP{
    # ToDo: create this sub as a customised version of processHTML()
    return processHTML();
}

############################################################################
sub processPHP{
    # ToDo: create this sub as a customised version of processHTML()
    return processHTML();
}

############################################################################
sub processSHTML{
    # ToDo: create this sub as a customised version of processHTML()
    return processHTML();
}

############################################################################
sub processHTML{
    $HTML_Counter++;
    my @lines = <CURRENTFILE>;
    my $wholeFile = join(" ",@lines);
    @lines = split(">", $wholeFile);
    foreach (@lines)
    {
        if ($_ =~ /(ID)/i)
        {
            processTAG_ID($_);
        }
        if ($_ =~ /(class)/i)
        {
            processTagCLASS($_);
        }
        if ($_ =~ /(<link.*href)/i)
        {
            processLink($_);
        }
        if ($_ =~ /(<script.*src)/i)
        {
            processScript($_);
        }
        if ($_ =~ /(<img)/i)
        {
            processIMG($_);
        }
        if ($_ =~ /(<form.*action)/i)
        {
            processFormAction($_);
        }

        ## Next REGEX may be too greedy. MJB 19/01/2009 23:15
        ## On the other hand, it may miss some genuine cases, eg:  "<a  href"  will NOT be matched due to double space
        if ($_ =~ /(<a.href)/i)
        {
            processHREF($_);
        }

        if ($_ =~ /(mailto)/i)
        {
            processMAILTO($_);
        }

    }
    displayMsg(33, "\n");  # End of line of indicator characters
}

############################################################################
sub processCSS{
    $CSS_Counter++;
    my @lines = <CURRENTFILE>;
    my $localTagList = '\b' . join('\b|\b', @bareTagNames) . '\b';
    # my $bareTagList  = join('|', @bareTagNames);

    foreach (@lines)
    {
        if ($_ =~ /url/i )
        {
            processURLinCSS($_);
        }
        if ($_ =~ /^(\#)/i)
        {
            processID($_);
        }
        if ($_ =~ /(\.)/i)
        {
            processCLASS($_);
        }
        ## if ($_ =~ /($localTagList)( |\.|{|\#|:)/i)
        if ($_ =~ /($localTagList)( |,|\.|{|\#|:)/i)
        {
            processTAG_css($_);
        }
    }
    displayMsg(33, "\n");
}

############################################################################
sub processImage{
    my $fileName = shift||'';
    # No need to read binary data, so pretty much ignore this file type, except:
    # Find out the file size:
    my $fileSize = -s $fileName;

    return $fileSize;
}
############################################################################
sub processJavascript{
    $JS_Counter++;
    my @lines = <CURRENTFILE>;
    my $lineNumber = 0;
    my $temp = '';
    foreach (@lines)
    {
        $lineNumber++;
        $temp = $_;
        $temp =~ s/\n$//;
        $temp =~ s/\r$//;


        #  = new function
        #  = new Function
        if ($temp =~ /=\s*new\s+function/i){
            displayMsg(5, "processJavascript 1a\n");
            processNewAnonFunction($temp, $lineNumber);
            next;
        }

        # Closures etc are just a specific type of anonymous function:
        #  = ( function
        if ($temp =~ /=\s*\(\s*function/i){
            displayMsg(5, "processJavascript 1b\n");
            processClosureFunction($temp, $lineNumber);
            next;
        }

        #  'named: function()'
        #  funcName : function
        if ($temp =~ /\S*\s*:\s*function/i){
            displayMsg(5, "processJavascript 1c\n");
            processAnonMethod($temp, $lineNumber);
            next;
        }

        #  function(param)
        if ($temp =~ /\bfunction\w+\([\W, ]\)/i){
            displayMsg(5, "processJavascript 1d\n");
            processAnonFunction($temp, $lineNumber);
            next;
        }


        #  methName = function
        if ($temp =~ /\s?\S+\s*=\s*function\s*/i){
            displayMsg(5, "processJavascript 2\n");
            processObjectMethod($temp, $lineNumber);
            next;
        }

        # Most generic match, must come last in this list:
        #  function funcName (
        if ($temp =~ /\bfunction\b/i){
            displayMsg(5, "processJavascript 3\n");
            processFunctionName($temp, $lineNumber);
            next;
        }
        # Next line should only be reachable by 'normal' JS code:
        displayMsg(20, "processJavascript: Ignoring: $lineNumber \"$temp\"\n");
        # If 'function code' gets this far, then one of the previous regexp's is too tight
    }
    displayMsg(33, "\n");
}
############################################################################
sub writePageData_HTML{
    my $thisFileNum = shift||'';
    my $shortFileSpec = mapFileName($thisFileNum, "HTML");
    my $outFileSpec = $gblMainDatFolder."/".$shortFileSpec;
    checkDatPath($shortFileSpec);

    unless (open OUTFILE_HTML, ">$outFileSpec")
    {
        displayMsg(999, "Unable to write to $outFileSpec: $!\n");
        return;
    }
    displayMsg(10, "Writing to: $outFileSpec\n");
    print OUTFILE_HTML       "HREF:".join("\nHREF:",     deDupeArray(@HREF_List));
    print OUTFILE_HTML   "\nMAILTO:".join("\nMAILTO:",   deDupeArray(@MAILTO_List));
    print OUTFILE_HTML "\nCSS-FILE:".join("\nCSS-FILE:", deDupeArray(@CSS_List));
    print OUTFILE_HTML  "\nJS-FILE:".join("\nJS-FILE:",  deDupeArray(@JS_List));
    print OUTFILE_HTML      "\nIMG:".join("\nIMG:",      deDupeArray(@IMG_List));
    print OUTFILE_HTML     "\nFORM:".join("\nFORM:",     deDupeArray(@FORM_List));
    print OUTFILE_HTML    "\nCLASS:".join("\nCLASS:",    deDupeArray(@TAG_CLASS_List));

# Clear these:
    @HREF_List   = ();
    @MAILTO_List = ();
    @CSS_List    = ();
    @JS_List     = ();
    @IMG_List    = ();
    @FORM_List   = ();
    @TAG_CLASS_List = ();

    close OUTFILE_HTML;
}
############################################################################
sub writePageData_CSS{
    my $thisFileNum = shift||'';
    my $shortFileSpec = mapFileName($thisFileNum, "CSS");
    my $outFileSpec = $gblMainDatFolder."/".$shortFileSpec;
    checkDatPath($shortFileSpec);

    unless (open OUTFILE_CSS, ">$outFileSpec")
    {
        displayMsg(999, "Unable to write to $outFileSpec: $!\n");
        return;
    }
    print OUTFILE_CSS "CLASS:".join("\nCLASS:",deDupeArray(@CLASS_List));
    print OUTFILE_CSS  "\nID:".join("\nID:",   deDupeArray(@ID_List));
    print OUTFILE_CSS "\nTAG:".join("\nTAG:",  deDupeArray(@TAG_List));
    print OUTFILE_CSS "\nURL:".join("\nURL:",  deDupeArray(@URL_List));

    @CLASS_List = ();
    @ID_List    = ();
    @TAG_List   = ();
    @URL_List   = ();

    close OUTFILE_CSS;
}
############################################################################
sub writePageData_JS{
    my $thisFileNum = shift||'';
    my $shortFileSpec = mapFileName($thisFileNum, "JS");
    my $outFileSpec = $gblMainDatFolder."/".$shortFileSpec;
    checkDatPath($shortFileSpec);

    unless (open OUTFILE_JS, ">$outFileSpec")
    {
        displayMsg(999, "Unable to write to $outFileSpec: $!\n");
        return;
    }
    # Next three lines will print 'blank lines' if the respective array is empty:
    print OUTFILE_JS   "FUNC:".join("\nFUNC:", deDupeArray(@FUNCTION_List_Trad));
    print OUTFILE_JS "\nANON:".join("\nANON:", deDupeArray(@FUNCTION_List_Anon));
    print OUTFILE_JS "\nCLOS:".join("\nCLOS:", deDupeArray(@FUNCTION_List_Closure));
    print OUTFILE_JS "\nMETH:".join("\nMETH:", deDupeArray(@FUNCTION_List_Method));

    @FUNCTION_List_Trad   = ();
    @FUNCTION_List_Anon   = ();
    @FUNCTION_List_Closure= ();
    @FUNCTION_List_Method = ();
    close OUTFILE_JS;
}
############################################################################
# Create HTML Page:
sub makeHTML_Page{
    my $thisFile  = shift||'';
    my $thisTitle = shift||'';
    my $outFileSpec = mapReportName($thisFile);
    displayMsg(20, "200169 Creating report file: $outFileSpec\n");
    unless (open OUTFILE_PAGE, ">$outFileSpec")
    {
        displayMsg(999, "20016A Unable to write to $outFileSpec: $!\n");
        return;
    }
    print OUTFILE_PAGE &getHTML_Header($thisTitle);
    print OUTFILE_PAGE "\n<body>";
    print OUTFILE_PAGE &getHTML_Footer();
    close OUTFILE_PAGE;

}
############################################################################
# Return the <HEAD> section of an HTML page
sub getHTML_Header{
    my $thisTitle = shift||'';
    my $output    = "";
    if (!$thisTitle) { $thisTitle = "Site Documentation"; }

    $output .= "<!DOCTYPE HTML>";
    $output .= "\n<head>";
    $output .= "\n<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>";
    $output .= "\n<title>";
    $output .= $thisTitle;
    $output .= " - siteDoc version";
    $output .= APP_VERSION;
    $output .= "</title>";
    $output .= "\n<link rel='stylesheet' href='";
    $output .= $configValues{"cssFileName"};
    $output .= "' type='text/css'>";
    $output .= "\n<script type='text/javascript' src='".$configValues{"jslocation"}."'></script>";
    $output .= "\n</head>\n";

    return $output;
}
############################################################################
# Return the footer section of a documentation page
sub getHTML_Footer{
    my $output     = "";
    my $isHomePage = shift;
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime time;
    my $actYear    = $year + 1900;
    if($isHomePage)
    {
        $output .= "\n<H3>End of main index page.</H3>";
    }else{
        $output .= "\n<H3><a href=\"/\">Back to main index</a></H3>";
    }
    $output .= "\n<H2>Produced on: $gblDateStamp</H2>";
    $output .= "\n<div id='divCopyright'>Created by SiteDoc.pl &#169; Copyright Mike Brockington 2007 - ".$actYear." &nbsp; All Rights Reserved</div>";
    $output .= "\n</body>";
    $output .= "</html>";

    return $output;
}
############################################################################
# Create HTML link:
sub getHTML_Link{
    my $output    = "";
    my $thisURL   = shift||'';
    my $thisTitle = shift||'';
    my $thisText  = shift||'';
    my $thisClass = shift||'';
        $output .= "<a href='";
        $output .= $thisURL;
        $output .= "' class='";
        $output .= $thisClass;
        $output .= "' title='";
        $output .= $thisTitle;
        $output .= "'>";
        $output .= $thisText;
        $output .= "</a>";
    return $output;
}
############################################################################
# Create HTML DIV:
sub getHTML_DIV{
    my $output     = "";
    my $innerText  = shift||'';
    my $thisClass  = shift||'';
        $output .= "<div ";
        $output .= "class='";
        $output .= $thisClass;
        $output .= "'>";
        $output .= $innerText;
        $output .= "</div>";
    return $output;
}
############################################################################
# Create HTML Heading:
sub getHTML_Heading{
    my $output     = "";
    my $thisNum    = shift||'';
    my $thisText   = shift||'';
    my $thisClass  = shift||'';
        $output .= "<h";
        $output .= $thisNum;
        $output .= " class='";
        $output .= $thisClass;
        $output .= "'>";
        $output .= $thisText;
        $output .= "</h";
        $output .= $thisNum;
        $output .= ">";
    return $output;
}
############################################################################
# Parse file spec:
sub getFileName{
    my $thisFile = shift||'';
       $thisFile =~ s/^.*[\/\\]//;
    return $thisFile;
}
############################################################################
# Parse file spec:
# ToDo: double check that this is working correctly. 01/03/2010
sub getFileExtension{
    my $thisExt = shift||'';
    $thisExt =~ s/^.*\.//;    # Remove everything upto and including the last dot in the given string
    return $thisExt;
}
############################################################################
# Map a Live URL to a file in the report area
sub mapFileToReportName{
    my $thisURL = shift||'';
    my $baseDir = $configValues{"siteRoot"};
    $baseDir =~ s/\/$//;             # Remove trailing slash if it exists
    $baseDir =~ s/^\\\\//;           # Remove leading double-backslash
    $baseDir =~ s/\./-/g;            # Replace any dots with hyphens
    $baseDir =~ s/\\/\//g;           # Replace backslashes with forward slashes
    $thisURL =~ s/^\///;             # Remove leading slash if it exists
    $thisURL =~ s/\.(\w*)$/-$1/;     # Replace trailing file-extension dot with a hyphen

    return "\/files\/".$baseDir."\/".$thisURL."\.html";
}
############################################################################
# Map a Live URL to a file in the report area
sub mapHREFtoReportName{
    my $thisURL = shift||'';
    my $finalStr = "";

    displayMsg(9, "mapHREFtoReportName: \($thisURL\)\n");

    $thisURL =~ s/^\///;             # Remove leading slash if it exists
    $thisURL =~ s/\.(\w*)$/-$1/;     # Replace trailing file-extension dot with a hyphen

    $finalStr = "/files/".$thisURL."\.html";

# MJB probably need to insert a bit more path, eg:
#    $finalStr = "/files/URLS/".$thisURL."\.html";
#                        ^^^^

    displayMsg(9, "mapHREFtoReportName \$finalStr: \"$finalStr\"\n");
    return $finalStr;
}
############################################################################
# Map a filesystem path to a file in the report area
sub mapReportName{
    my $thisFile = shift||'';
    my $reportBase = $configValues{"reportBase"};
    $reportBase =~ s/[\/\\]$//;             # Remove trailing slash if it exists
    return $reportBase."/".$thisFile;
}
############################################################################
# Take a filename and path in the temp area
# Map the given path to a safe HTML filename
sub mapShortDatFileName{
    my $thisDatFile  = shift||'';
          $thisDatFile =~ s/$dataStoreEscaped\///i;                #  Remove 'dataStore' path, and trailing slash
          $thisDatFile =~ s/\.dat//i;                               # Remove unwanted file extension
          $thisDatFile =~ s/\//\\/g;                                 #Replace forward slashes with backslashes

    displayMsg(5, "mapShortDatFileName inter: $thisDatFile\n");

    return $configValues{"reportBase"}."/files/".$thisDatFile.".html";
}
############################################################################
# Take a filename and path in the temp area
# Map the given path to a safe HTML filename
sub mapDatFileName{
    my $thisFile  = shift||'';
    my $dataStore = $gblMainDatFolder;
       $dataStore =~ s/\\/\\\\/gi;  # Replace backslash with double-backslash, so that it is 'escaped' for the next RegExp

    displayMsg(5, "mapDatFileName initial: $thisFile\n");
    $thisFile =~ s/$dataStore\///i;                                              # Remove 'dataStore' path, and trailing slash
    $thisFile =~ s/HTML|css|js//i;                                               # Replace unwanted folder structure - Top Level
    $thisFile =~ s/links|TAG_IDs|TagCLASS|Links|Scripts|IMG|FormActions|HREF//i; # Replace unwanted folder structure - HTML
    $thisFile =~ s/IDs|CLASS|TAGs//i;                                            # Replace unwanted folder structure - CSS
    $thisFile =~ s/AnonFunctions|ObjectMethods|Functions//i;                     # Replace unwanted folder structure - JavaScript
    $thisFile =~ s/\.dat//i;                                                     # Remove unwanted file extension

    $thisFile =~ s/\/\//\//g;    # Remove any double slashes caused by removal of folders above, replace with a single slash
    displayMsg(5, "mapDatFileName intermediate: $thisFile\n");

    return $configValues{"reportBase"}."/files".$thisFile.".html";
}
############################################################################
# Take a filename and return only the ID, as a decimal
sub extractFileID{
    my $thisFile  = shift||'';
    displayMsg(9, "extractFileID initial: $thisFile\n");

    if($thisFile =~ /[0-9a-f]+/i)
    {
        $thisFile =~ s/.*[\/\\]//;
        $thisFile =~ s/\..*//;

        return hex( $thisFile );      # Convert thisFile from Hex back to decimal
    }else{
        displayMsg(99, "extractFileID failed: $thisFile\n");
        return "-1";  # Not a valid ID
    }
}
############################################################################
# Create a hyperlink based on the given strings
# General Version to link to files that are part of the documented server
# Original Version:
sub getReportLink{
    my $thisHREF  = shift||'';
    my $thisTitle = shift||'';

    return "<a href='".$thisHREF."'>".$thisTitle." (xii Orig) </a>";
}
############################################################################
# Create a hyperlink based on the given strings
# General Version to link to files that are part of the documented server
sub getReportLinkHREF{
    my $thisHREF  = shift||'';
    my $thisTitle = shift||'';

    return "<a href='".$thisHREF."'>".$thisTitle." (xii 1) </a>";
}
############################################################################
# Create a hyperlink based on the given strings
# General Version to link to files that are part of the documented server
sub getReportLinkIMG{
    my $thisHREF  = shift||'';
    my $thisTitle = shift||'';
       $thisTitle =~ s/\s+$//;               #  Remove trailing newline/whitespace chars, if any exists
    my $infoHREF  = mapHREFtoReportName($thisTitle) || '';

    my $prefix = "<a href='".$thisHREF."'>Link to live</a>";
    my $title  = $thisTitle." (xii 2)";
    my $suffix = "<a href='".$infoHREF."'>Info Page</a>";

    return $prefix." ".$title." ".$suffix;
}
############################################################################
# Create a hyperlink based on the given strings
# General Version to link to files that are part of the documented server
sub getReportLinkJSFile{
    my $thisHREF  = shift||'';
    my $thisTitle = shift||'';

    return "<a href='".$thisHREF."'>".$thisTitle." (xii 3) </a>";
}
############################################################################
# Create a hyperlink based on the given strings
# General Version to link to files that are part of the documented server
sub getReportLinkFORM{
    my $thisHREF  = shift||'';
    my $thisTitle = shift||'';

    return "<a href='".$thisHREF."'>".$thisTitle." (xii 4) </a>";
}
############################################################################
# Create a hyperlink based on the given strings
# General Version to link to files that are part of the documented server
sub getReportLinkCSSfile{
    my $thisHREF  = shift||'';
    my $thisTitle = shift||'';

    return "<a href='".$thisHREF."'>".$thisTitle." (xii 5) </a>";
}
############################################################################
# Create a hyperlink based on the given strings
# General Version to link to files that are part of the documented server
sub getLiveURL{
    my $thisHREF  = shift||'';
    my $strOutput = '';

    displayMsg(9, "getLiveURL: \$thisHREF = $thisHREF\n");

    $strOutput .= "$thisHREF - ";
    $strOutput .= "<a href='".$thisHREF."' rel='external'>Live Resource (xxi) </a>";

    return $strOutput;
}

############################################################################
# Create a hyperlink based on the given strings
# General Version to link to non-file info pages
sub getNonFileLink{
    my $thisHREF  = shift||'';
    my $linkText  = shift||$thisHREF;

    $linkText =~ s/\s+$//;               #  Remove trailing newline/whitespace chars, if any exists

    ## print "getNonFileLink > \$linkText:".$linkText."\n";

## MJB ToDo: change this function to make use of $thisPath; change code elsewhere to deposit files in correct folder/sub-folder:
    return "<a href='/lists/".$thisHREF."\.html'>".$linkText."(x) </a>";
}
############################################################################
# Create a hyperlink based on the given strings
# Special Version for data files
sub getReportDataLink{
    my $thisInput = shift||'';
    my $thisHREF  = mapFileToReportName($thisInput) || '';

    return getReportLink($thisHREF, $thisInput);
}
############################################################################
# Map the original file name to a reportID
sub getInfoPageURL{
    my $thisString = shift||'';

    # Massage the provided URL:
    $thisString =~ s{^#}{_};               #  Replace a leading hash char, if it exists
    $thisString =~ s{^/}{};                #  Remove a leading slash, if it exists
    $thisString =~ s/\s+$//;               #  Remove a trailing newline/whitespace char, if any exists
    displayMsg(99, "getInfoPageURL: \"$thisString\"\n");

    my $fullURL = $configValues{"siteRoot"}."\/".$thisString;

    # Find this file in @gblFileArray:
    my $index = getFileNameTwo($fullURL);
    my $pathPrefix = getFileClass($thisString);
    displayMsg(99, "getInfoPageURL: \$index: \"$index\"\n");

    ## ToDo: MJB write something appropriate for when we get -1 returned by getFileNameTwo()
    return $configValues{"reportBase"}."/files/".$pathPrefix."/".getFileAndFolderFromID($index + 1).".html";
}

############################################################################
# Create a hyperlink based on the given string
# where data is already an HREF
sub getReportHREFLink{
    my $thisString = shift||'';
    my $shortURL   = shift||$thisString;
    my $infoPageURL = '';

    if( $thisString =~ m/^\#/ )                        # Check if the URL starts with a  # character
    {
        return $thisString;
    }else{
        # Decide if this is an internal or external URL:
        if( $thisString !~ m/^http/i )
        {
            if( $thisString !~ m/^\// )    # No leading slash means this is a relative URL
            {
                return $thisString;        # ToDo: Work out the current folder structure, and build this into an absolute URL.  MJB 20/03/2009
            }
            $thisString = $configValues{"baseURL"}.$thisString;
            $infoPageURL = getInfoPageURL($shortURL);    # Map the original file name to a reportID
            displayMsg(81, "getReportHREFLink \$infoPageURL = ".$infoPageURL."\n");
            return getReportLinkHREF($thisString, "Link to Live")." $shortURL ".getReportLinkHREF($infoPageURL, "Info Page (xix)");
        }
        # ToDo: Also need to check whether an absolute URL is actually part of the server that we are trying to document. MJB 21/03/2009
        return getReportLinkHREF($thisString, $shortURL);
    }
}
############################################################################
# Create a hyperlink based on the given string
# where data is an image file
# Link to local (dev) web server
sub getIMGLink{
    my $thisString = shift||'';
    my $shortURL   = shift||$thisString;

    # Decide if this is an internal or external URL:
    if( $thisString !~ m/^http/i )
    {
        if( $thisString !~ m/^\// )    # No leading slash means this is a relative URL
        {
            # ToDo: Work out the current folder structure, and build this into an absolute URL.  MJB 20/03/2009
            $thisString = $configValues{"testRoot"}."\/".$thisString;
            return getReportLinkIMG($thisString, $shortURL);
        }else{
            # Must be an absolute URL:
            $thisString = $configValues{"testRoot"}."\/".$thisString;
            return getReportLinkIMG($thisString, $shortURL);
        }
    }else{
        # This is an FQDN URL, so return as-is:
        return getReportLinkIMG($thisString, $shortURL);  # ToDo: shorten $shortURL down to just the file name?
        # ToDo: Also need to check whether an absolute URL is actually part of the server that we are trying to document. MJB 21/03/2009
    }
    return "EXCEPTION: 20F1F4 (\$thisString: '$thisString')";
}

############################################################################
# Create a hyperlink based on the given string
# where data is an image file
# Link to local (dev) web server
sub getReportJSFILELink{
    my $thisString = shift||'';
    my $shortURL   = shift||$thisString;

    # Decide if this is an internal or external URL:
    if( $thisString !~ m/^http/i )
    {
        if( $thisString !~ m/^\// )    # No leading slash means this is a relative URL
        {
            return $thisString;        # ToDo: Work out the current folder structure, and build this into an absolute URL.  MJB 20/03/2009
        }else{
            # Must be an absolute URL:
            $thisString = $configValues{"testRoot"}.$thisString;
            return getReportLinkJSFile($thisString, $shortURL);
        }
    }else{
        # This is an FQDN URL, so return as-is:
        return getReportLinkJSFile($thisString, $shortURL);  # ToDo: shorten $shortURL down to just the file name?
        # ToDo: Also need to check whether an absolute URL is actually part of the server that we are trying to document. MJB 21/03/2009
    }
    return "EXCEPTION: 20F1EF (\$thisString: '$thisString')";
}
############################################################################
# Create a hyperlink based on the given string
# where data is an image file
# Link to local (dev) web server
sub getReportFORMFLink{
    my $thisString = shift||'';
    my $shortURL   = shift||$thisString;

    # Decide if this is an internal or external URL:
    if( $thisString !~ m/^http/i )
    {
        if( $thisString !~ m/^\// )    # No leading slash means this is a relative URL
        {
            return $thisString;        # ToDo: Work out the current folder structure, and build this into an absolute URL.  MJB 20/03/2009
        }else{
            # Must be an absolute URL:
            $thisString = $configValues{"testRoot"}.$thisString;
            return getReportLinkFORM($thisString, $shortURL);
        }
    }else{
        # This is an FQDN URL, so return as-is:
        return getReportLinkFORM($thisString, $shortURL);  # ToDo: shorten $shortURL down to just the file name?
        # ToDo: Also need to check whether an absolute URL is actually part of the server that we are trying to document. MJB 21/03/2009
    }
    return "EXCEPTION: 20F1F1 (\$thisString: '$thisString')";
}
############################################################################
# Create a hyperlink based on the given string
# where data is an image file
# Link to local (dev) web server
sub getReportCSSFILELink{
    my $thisString = shift||'';
    my $shortURL   = shift||$thisString;

    # Decide if this is an internal or external URL:
    if( $thisString !~ m/^http/i )
    {
        if( $thisString !~ m/^\// )    # No leading slash means this is a relative URL
        {
            return $thisString;        # ToDo: Work out the current folder structure, and build this into an absolute URL.  MJB 20/03/2009
        }else{
            # Must be an absolute URL:
            $thisString = $configValues{"testRoot"}.$thisString;
            return getReportLinkCSSfile($thisString, $shortURL);
        }
    }else{
        # This is an FQDN URL, so return as-is:
        return getReportLinkCSSfile($thisString, $shortURL);  # ToDo: shorten $shortURL down to just the file name?
        # ToDo: Also need to check whether an absolute URL is actually part of the server that we are trying to document. MJB 21/03/2009
    }
    return "EXCEPTION: 20F1F2 (\$thisString: '$thisString')";
}
############################################################################
# Create a hyperlink based on the given string
# where input is the contents of a: URL()  link
# Probably a local resource, so try to link to the live URL
sub getReportURLLink{
    my $thisString = shift||'';

    displayMsg(8, "getReportURLLink: \$thisString = $thisString\n");

    # Decide if this is an internal or external URL:
    if( $thisString !~ m/^http/i )
    {
        # This is NOT an FQDN URL, so need to massage it a little:
        if( $thisString !~ m/^\// )
        {
            # No leading slash means this is a relative URL
            # ToDo: Work out the current folder structure, and build this into an absolute URL.  MJB 20/03/2009
            return getLiveURL($thisString);
        }else{
            # Looks like an absolute URL:
            $thisString = $configValues{"testRoot"}.$thisString;
            return getLiveURL($thisString);
        }
    }else{
        # This is an FQDN URL, so return as-is:
        return getLiveURL($thisString);  # ToDo: shorten $shortURL down to just the file name?
        # ToDo: Also need to check whether an absolute URL is actually part of the server that we are trying to document. MJB 21/03/2009
    }
    return "EXCEPTION: 20F1F3 (\$thisString: '$thisString')";
}

############################################################################
# Create a hyperlink based on the given string
# for 'second-pass data'
sub getDataLink{
    my $thisString = shift;
    my $currentLinkType = shift;
    if (!$thisString)
    {
        displayMsg(80, "Warning: 20F16C No data passed to sub getDataLink()\n");
        return;
        # Can't do anything if we don't have any text
    }else{
        displayMsg(30, "Sub: getDataLink( $thisString )\n");
    }
    my $linkLocation = $thisString;
    if($linkLocation eq "*")
    {
        $linkLocation = "STAR";     # A 'raw' asterisk causes all sorts of problems
    }
    $linkLocation =~ s/Line://g;    # Remove line number marker, but leave the actual line number
    $linkLocation =~ s/[()]//g;     # Remove any round brackets
    $linkLocation =~ s/[^a-zA-Z0-9]/_/g;  # Replace non-alpha chars with underscores

    return "<a href='/$currentLinkType/$linkLocation.html'>$thisString</a>";
}############################################################################
# Extract a line number from the given string
# for 'second-pass data'
sub getDataLine{
    my $thisString = shift;
    my $thisLineNum = 0;
    my $temp = "";

    if (!$thisString)
    {
        displayMsg(80, "Warning: 999 No data passed to sub getDataLine()\n");
        return 0;
        # Can't do anything if we don't have any text
    }else{
        displayMsg(30, "Sub: getDataLine( $thisString )\n");
        ($temp, $thisLineNum) = split(":", $_, 2);
    }

    # MJB ToDo: Just to be safe; we should probably parse this value as a number...
    # But that would add complexity...
    return $thisLineNum;
}
############################################################################
# Create a human-readable page title based on the given path
#
sub mapDatFileNameToPageTitle{
    my $thisFile = shift||'';
    my $thisID   = extractFileID($thisFile)||'';
    my $currentLinkType = shift||'';
    if($thisID > 0)
    {
        my $thisName = $gblFileArray[$thisID - 1] || "20F18E";

        displayMsg(80, "Sub: mapDatFileNameToPageTitle(\$thisID = $thisID");
        displayMsg(80, " => $thisName)\n");

    #    $thisName =~ s/^files\///g;           # Remove structure added by this program
    #    $thisName =~ s/-html\.html$/\.html/;  # Remove signature of the temp area - html   # Would be good to do this in a more generic way...
    #    $thisName =~ s/-js\.js$/\.js/;        # Remove signature of the temp area - js
    #    $thisName =~ s/-css\.css$/\.css/;     # Remove signature of the temp area - css    # MJB How many more of these lines do we need!
    #    $thisName =~ s/_/ /g;                 # Replace underscores with a space
    #    $thisName =~ s/  +/ /g;               # Condense multiple spaces
        $thisName =~ s/\//&#x200B;\//g;       # Insert a zero-width-space before every forward slash, so that any line-wrapping occurs in a nice place
        $thisName =~ s/\\/&#x200B;\//g;       # Insert a zero-width-space before every backslash,     ditto
        return $thisName;
    }else{
        return "ERR:20F18D extractFileID(".$thisFile.") \$thisID = $thisID";
    }
}

############################################################################
# Create a human-readable page title based on the given path
#
sub mapReportDataPathToPageTitle{
    my $thisName = shift || "Blank";
    my $titlePrefix = shift||'';

    displayMsg(5, "Sub: mapReportDataPathToPageTitle($thisName)\n");

    return $titlePrefix.": ".$thisName;
}
############################################################################
# Create a filename and path for the temp area
# Map the given path to a safe filename,
# Choose a folder based on: prefix,
# Choose a sub-folder based on: prefix2,
# Add a  .dat  extension.
sub mapFileName{
    my $thisFileNum = shift || 0;
    my $thisPrefix  = shift||'';
    my $fileID = getFileAndFolderFromID($thisFileNum );

    return $thisPrefix."/".$fileID.".dat";
}
############################################################################
# Remove duplicates and sort the result
sub deDupeArray{
    my %seen = ();
    my $item;

    while ($item = shift)
    {
        $item =~ s/[\r\n]//;   # Sometimes we have a trailing line-break, which confuses the next comparison
        unless($seen{$item})
        {
            $seen{$item} = 1;
        }
    }
    return sort(keys %seen);
}
############################################################################
# Set required values etc.
sub checkConfig{
    if(! $configValues{"siteName"})           {  $configValues{"siteName"} = "localhost"; }
    if(! $configValues{"stylesheetlocation"}) {  $configValues{"stylesheetlocation"} = "\\default.css"; }
    if(! $configValues{"jslocation"})         {  $configValues{"jslocation"} = "\\default.js"; }
    # Check that all of the folders we need already exist:
    ensureFolderExists($configValues{"dataStore"});
    ensureFolderExists($gblMainDatFolder);
    ensureFolderExists($gblSecondaryDatFolder);

    ensureFolderExists($configValues{"reportBase"});
    ensureFolderExists($configValues{"reportBase"}."/folders");      # Storage for HTML reports of folder contents
    ensureFolderExists($configValues{"reportBase"}."/files");        # Storage for HTML reports of file contents
}


############################################################################
# Set required values etc.
sub readConfig{
    open (CONFIG_FILE, CONFIG_FILE_NAME) || die "Fatal Error 20F16E: Unable to read from '".CONFIG_FILE_NAME."': $!\n";
    ## Global:
    ## $configValues;
    while(<CONFIG_FILE>)
    {
        chomp;
        s/#.*//;
        s/^\s+//;
        s/\s+$//;
        next unless length;
        my ($item, $value) = split(/\s*=\s*/, $_, 2);
        $configValues{$item} = $value;
    }
    close CONFIG_FILE;
}

############################################################################
# Make sure that this is a file that we understand
# There shouldn't be any other files in this area, but you never know!!
# Not quite sure what the file signature should be...
sub checkDatFileFormat{
    my $pathName = shift||'';
    # ToDo: Pretty much Everything !!! MJB 16/02/2009 19:58
        return 99; # TRUE / Okay
    # return 0; # FALSE / bad format
}

############################################################################
# Create required folders if they no not exist already
# This version is intended to handle UNC paths
sub checkReportPath{
    my $startPath = $configValues{"reportBase"};
    my $endOfPath = shift(@_);
    my @folders;
    my $pathItem;

    $endOfPath =~ s/[\/\\][^\/\\]+\.[^\/\\]+$//;    # Remove any filename.ext at the end of the string
    displayMsg(10, "Sub: checkReportPath( $startPath, $endOfPath )\n");
    @folders = split /[\\\/]/, $endOfPath;          # Split on back or forward slash
    my $pathName = "";
    my $currentFolder = "";
    foreach $pathItem ( @folders )
    {
        $pathName = join "/", $pathName,$pathItem;
        $pathName =~ s/^\///;      # Remove any leading slash
        $currentFolder = $startPath."/".$pathName;
        displayMsg(10, "checkReportPath: $currentFolder\n");
        ensureFolderExists( $currentFolder);
    }
}

############################################################################
# Create required folders if they no not exist already
# This version is intended to handle UNC paths
# MJB ToDo: keep a record of paths checked - should be a bit faster than doing a physical check hundreds of times.
# But probably not enough to be important
sub checkFullReportPath{
    my $pathItem;
    my $startPath = $configValues{"reportBase"};
    my $endOfPath = shift(@_);
       $endOfPath =~ s/$reportBaseEscaped[\\\/]//i;                       #  Remove 'reportBase' path, and trailing slash
       $endOfPath =~ s/[\/\\][^\/\\]+\.[^\/\\]+$//;                  #   Remove any filename.ext at the end of the string
    displayMsg(8, "Sub: checkFullReportPath( $startPath, $endOfPath )\n");
    my @folders = split /[\\\/]/, $endOfPath;                      #     Split on back or forward slash
    my $pathName = "";
    my $currentFolder = "";
    foreach $pathItem ( @folders )
    {
        $pathName = join "/", $pathName,$pathItem;
        $pathName =~ s/^\///;      # Remove any leading slash
        $currentFolder = $startPath."/".$pathName;
        displayMsg(10, "checkReportPath: $currentFolder\n");
        ensureFolderExists( $currentFolder);
    }
}

############################################################################
# Create required folders if they no not exist already
# This version is intended to handle UNC paths
sub checkReportDataPath{
    my $pathItem;
    my $startPath = $configValues{"reportBase"};
    my $endOfPath = shift(@_);
    my $startPathLen = length($startPath);
    my $temp = substr($startPath, 0, $startPathLen);
    if($temp eq $startPath)
    {
        $endOfPath = substr($endOfPath, $startPathLen, length($endOfPath) );
        displayMsg(10, "\$endOfPath has now become: $endOfPath\n");
    }
    $endOfPath =~ s/[\/\\][^\/\\]+\.[^\/\\]+$//;       # Remove any filename.ext at the end of the string
    my @folders = split /[\\\/]/, $endOfPath;          # Split on back or forward slash
    my $currentFolder = "";
    foreach $pathItem ( @folders )
    {
        $currentFolder = join "/", $currentFolder,$pathItem;
        $currentFolder =~ s/^\///;      # Remove any leading slash
        displayMsg(10, "checkReportDataPath: $currentFolder\n");
        ensureFolderExists( $configValues{"reportBase"}."/".$currentFolder);
    }
}

############################################################################
# Create required folders if they no not exist already
# This version is intended to handle UNC paths
sub checkDatPath{
    my $pathItem;
    my $startPath = $gblMainDatFolder;
    my $endOfPath = shift(@_);
    $endOfPath =~ s/[\/\\][^\/\\]+\.[^\/\\]+$//;    # Remove any filename.ext at the end of the string
    displayMsg(10, "Sub: checkDatPath( $startPath, $endOfPath )\n");
    my @folders = split /[\\\/]/, $endOfPath;      # Split on back or forward slash
    my $pathName = "";
    my $currentFolder = "";
    foreach $pathItem ( @folders )
    {
        $pathName = join "/", $pathName, $pathItem;
        $pathName =~ s/^\///;                   # Remove any leading slash
        $currentFolder = $startPath."/".$pathName;
        displayMsg(10, "# Checking folder: $currentFolder\n");
        ensureFolderExists( $currentFolder);
    }
}

############################################################################
# Create required folders if they no not exist already
sub ensureFolderExists{
    my $pathName = shift||'';
    if (-w $pathName)
    {
        displayMsg(10, "Folder found: $pathName\n");
    } else {
        displayMsg(20, "Creating folder: $pathName\n");
        mkdir $pathName;
    }
}

############################################################################
# Return the top section of a documentation page
sub getHTML_Top{
    my $strTitle = shift;
    my $output = "";

    if(! $strTitle)
    {
        $strTitle = "SiteDoc Documentation for ".$configValues{"siteName"};
    }
    $output .= getHTML_Header($strTitle);
    $output .= "\n<body>";
    if($configValues{"logolocation"})
    {
        $output .= "<a href=\"/\" title=\"Back to main index\">";
        $output .= "<img class='siteLogo' src='".$configValues{"logolocation"}."'>";
        $output .= "</a>";
    }
    $output .= "\n<H1>".$strTitle."</H1>";
    $output .= "\n<div id='mainDiv'>";
    $output .= "\n<H2>File List:</H2>";

    return $output;
}
############################################################################
# Return the top section of a documentation page
sub getReport_Top{
    my $strTitle = shift||'';
    my $output = "";
    my $pageTitle = "SiteDoc Documentation for ".$configValues{"siteName"};

    $output .= getHTML_Header($pageTitle);
    $output .= "\n<body>";
    if($configValues{"logolocation"}) { $output .= "<img class='siteLogo' src='".$configValues{"logolocation"}."'>"; }
    $output .= "\n<H1>File Contents</H1>";
    $output .= "\n<div id='mainDiv'>";
    $output .= "\n<H2>".$strTitle."</H2>";

    return $output;
}############################################################################
# Return the top section of a documentation page
sub getListReport_Top{
    my $strTitle = shift||'';
    my $output = "";
    my $pageTitle = "SiteDoc Documentation for ".$configValues{"siteName"};

    $output .= getHTML_Header($pageTitle);
    $output .= "\n<body>";
    if($configValues{"logolocation"}) { $output .= "<img class='siteLogo' src='".$configValues{"logolocation"}."'>"; }
    $output .= "\n<H1>Usage of $strTitle</H1>";
    $output .= "\n<div id='mainDiv'>";

    return $output;
}
############################################################################
# Return a pair of links to the specified page
sub getDoubleFileLink{
    my $strInput  = shift||'';
    my $strOutput = "";

    $strOutput .= "<a href='".getLinkToInfoPage($strInput)."' rel='internal'>Info (v)</a>";
    $strOutput .= " - $strInput - ";
    $strOutput .= "<a href='".getLinkToLive($strInput)."' rel='external'>Live Page</a>";

    return $strOutput;
}
############################################################################
# Return a pair of links to the specified page
sub getFirstPassDoubleFileLink{
    my $numInput  = shift|| 0;
    my $strInput  = shift||'';
    my $strFolder = shift||'';
    my $strOutput = "";

        displayMsg(20, "getFirstPassDoubleFileLink folder: $strFolder\n");

    # MJB ToDo: Add image types
    if(($strFolder eq "CSS") || ($strFolder eq "HTML") || ($strFolder eq "JS") ){
      $strOutput .= "<a href='".getFirstPassLinkToInfoPage($numInput, $strFolder)."' rel='internal'>Info (i)</a>";
    }else{
      # MJB ToDo: Link to generic page that explains which file formats are handled?
      $strOutput .= "No Info (i)";
    }
    $strOutput .= " - $strInput - ";
    $strOutput .= "<a href='".getLinkToLive($strInput)."' rel='external'>Live Page</a>";

    return $strOutput;
}
############################################################################
# Return a pair of links to the specified page, custom version of getFirstPassDoubleFileLink()
sub getFirstPassDoubleFileImageLink{
    my $numInput  = shift|| 0;
    my $strInput  = shift||'';
    my $strFolder = shift||'';
    my $strFileSize = shift||0;
    my $strOutput = "";

    displayMsg(2, "getFirstPassDoubleFileImageLink folder: $strFolder\n");

   ### # MJB ToDo: Add image types
   ### if(($strFolder eq "CSS") || ($strFolder eq "HTML") || ($strFolder eq "JS") ){
   ###   $strOutput .= "<a href='".getFirstPassLinkToInfoPage($numInput, $strFolder)."' rel='internal'>Info (i)</a>";
   ### }else{
   ###   # MJB ToDo: Link to generic page that explains which file formats are handled?
   ###   $strOutput .= "No Info (i)";
   ### }
    $strOutput .= "$strFileSize bytes";
    $strOutput .= " - $strInput - ";
    $strOutput .= "<a href='".getLinkToLive($strInput)."' rel='external'>Live Page</a>";

    return $strOutput;
}
############################################################################
# Return a link to info page for the specified folder
sub getFirstPassFolderLink{
    my $numInput  = shift|| 0;
    my $strInput  = shift||'';
    my $strOutput = "";
        $strOutput .= "<a href='".getFirstPassLinkToFolderInfoPage($numInput)."' rel='internal'>Info (ii) T.B.C.</a>";
        $strOutput .= " - $strInput ";
        $strOutput .= "(Folder)";
    return $strOutput;
}
############################################################################
# Return a link to info page for the specified folder
sub getFolderLink{
    my $strInput  = shift||'';
    my $strOutput = "";
        $strOutput .= "<a href='".getLinkToFolderInfoPage($strInput)."' rel='internal'>Info (iii)</a>";
        $strOutput .= " - $strInput ";
        $strOutput .= "(Folder)";
    return $strOutput;
}
############################################################################
# Returns the HTTP path on the documented site of the specified file
sub getLinkToLive{
    my $thisFile = shift||'';
    my $siteRootEscaped = $configValues{"siteRoot"};
    $siteRootEscaped =~ s/\\/\\\\/gi;                                 # Replace backslash with double-backslash
    $thisFile =~ s/$siteRootEscaped/$configValues{"testRoot"}/i;      # Replace local path with remote path
    return $thisFile;
}
############################################################################
# Returns the HTTP path on the documented site of the specified file
sub mapLinkToLive{
    my $thisFile = shift||'';
    my $siteRootEscaped = $configValues{"siteRoot"};
    $siteRootEscaped =~ s/\\/\\\\/gi;                  # Replace backslash with double-backslash
    $thisFile =~ s/$siteRootEscaped//i;                # Replace local path with remote path
    return $thisFile;
}
############################################################################
sub removeSiteRoot{
    my $thisFile = shift||'';
    my $siteRootEscaped = $configValues{"siteRoot"};
    $siteRootEscaped =~ s/\\/\\\\/gi;                                 # Replace backslash with double-backslash
    $thisFile =~ s/$siteRootEscaped//i;                               # Remove local path
    return $thisFile;
}
############################################################################
# Returns the path on the SiteDoc site of the information page for the specified file
sub getLinkToInfoPage{
    my $thisFile = shift||'';
    displayMsg(10, "Sub: getLinkToInfoPage( \$thisFile: $thisFile )\n");
    my $fileOut = getFileFromDat($thisFile );
    displayMsg(10, "Sub: getLinkToInfoPage( \$fileOut: $fileOut )\n");
    $fileOut =~ s/\\/\//g;           # Replace any backslashes with forward slashes so that this works in a URL

    return "files/$fileOut.html";
}
############################################################################
# Returns the path on the SiteDoc site of the information page for the specified file
sub getSecondPassLinkToInfoPage{
    my $thisFile = shift||'';
    displayMsg(10, "Sub: getSecondPassLinkToInfoPage( \$thisFile: $thisFile )\n");
    $thisFile =~ s/$dataStoreEscaped\///i;   #  Remove 'dataStore' path, and trailing slash
    $thisFile =~ s/\\/\//g;                   # Replace any remaining backslashes with forward slashes so that this works in a URL
    $thisFile =~ s/dat/html/g;                 #Replace the 'dat' file extension
    displayMsg(10, "[2]: getSecondPassLinkToInfoPage( \$thisFile: $thisFile )\n");

    return "files/$thisFile";
}
############################################################################
# Returns the path on the SiteDoc site of the information page for the specified file
sub getFirstPassLinkToFolderInfoPage{
    my $thisID = shift|| 0;
    displayMsg(10, "Sub: getFirstPassLinkToFolderInfoPage( \$thisID: $thisID )\n");
    my $fileID = getFileAndFolderFromID($thisID );
    $fileID =~ s/\\/\//g;           # Replace any backslashes with forward slashes so that this works in a URL

    return "folders/$fileID.html";
}
############################################################################
# Returns the path on the SiteDoc site of the information page for the specified file
sub getLinkToFolderInfoPage{
    my $thisFolder = shift||'';
    displayMsg(10, "Sub: getLinkToFolderInfoPage( \$thisFolder: $thisFolder )\n");
    my $fileID = getFileFromDat($thisFolder );
    $fileID =~ s/\\/\//g;           # Replace any backslashes with forward slashes so that this works in a URL

    return "folders/$fileID.html";
}
############################################################################
# Returns the path on the SiteDoc site of the information page for the specified file
sub getFirstPassLinkToInfoPage{
    my $numInput  = shift|| 0;
    my $strFolder = shift|| "";
    displayMsg(10, "Sub: getFirstPassLinkToInfoPage( \$numInput: $numInput, \$strFolder: $strFolder )\n");
    my $fileID = getFileAndFolderFromID($numInput );
    $fileID =~ s/\\/\//g;           # Replace any backslashes with forward slashes so that this works in a URL

    return "files/$strFolder/$fileID.html";
}
############################################################################
# Returns the correct path prefix
sub getFileClass{
    my $thisFile = shift|| 0;
    my $retVal = "folders";   # Default value

    ## ($thisType, $thisRemainder) = split("/", $thisFile, 2);
    my ($thisType) = split("/", $thisFile);

    displayMsg(20, "Sub: getFileClass\n");
    displayMsg(2, "getFileClass: \$thisFile:$thisFile\n");
    displayMsg(200, "getFileClass: \$thisType:$thisType\n");

        if($thisType eq "css")
            { $retVal = $thisType; }
        if($thisType eq "js")
            { $retVal = $thisType; }
        if($thisType eq "img")
            { $retVal = $thisType; }
        if($thisType eq "http:")
            { $retVal = "HTML"; }

        if(index($thisType, "\#") == 0 )
            { $retVal = "HTML"; }
        if(index($thisType, "\.html") > -1 )
            { $retVal = "HTML"; }

### getFileClass: $thisType:#Definition
### getFileClass: $thisType:#Formulae
### getFileClass: $thisType:#Instructions
### getFileClass: $thisType:http:
### getFileClass: $thisType:css
### getFileClass: $thisType:generic_files
### getFileClass: $thisType:js
### getFileClass: $thisType:noScript.html

    return $retVal;
}
############################################################################
# Returns the path on the live site of the information page for the specified file
sub getFileAndFolderFromID{
    my $thisID = shift|| 0;
    my $fileID = sprintf("%x", $thisID );
    my $folderID = substr($fileID, -1, 1); # Grab the last character so that we can segment the files a little
    displayMsg(10, "Sub: getFileAndFolderFromID( \$thisID: => $fileID)\n");

    return "$folderID/$fileID";
}
############################################################################
# Returns the HTTP path on the documentation site of the information page for the specified file
sub getReportFromDat{
    my $thisDATfile = shift;
    my $thisFile = $thisDATfile;

    if ($thisFile)
    {
        $thisFile =~ s/.*\\dats/\/files/i;   # Replace everything up to, and including "\dats\" with "/files/"
        $thisFile =~ s/\.dat/\.html/i;       # Change file extention from  .dat   to  .html
    }else{
        displayMsg(999, "ERROR: getReportFromDat( \$thisFile: $thisFile not 'truthy')\n");
    }
    displayMsg(9, "Sub: getReportFromDat( \$thisDATfile: $thisDATfile changed to: $thisFile)\n");

    return $thisFile;
}
############################################################################
# Returns the path on the live site of the information page for the specified file
sub getFileFromDat{
    my $thisDATfile = shift;
    my $thisFile = "";
    if ($thisDATfile)
    {
        $thisFile = getFileID($thisDATfile);
    }
    displayMsg(59, "Sub: getFileFromDat( \$thisDATfile: $thisDATfile => $thisFile)\n");

    return $thisFile;
}
############################################################################
# Returns the filename that corresponds to the ID of a particular DAT file
sub getFileID{
    my $thisInput = shift||'';
    my $thisID = "";
    my $thisFile;

    if (!$thisInput)
    {
        $thisFile = "";
        displayMsg(75, "WARNING: 20F1D8 getFileID() - \$thisInput is blank\n");
    }else{
        $thisID = getFileName($thisInput);   # Remove all of the path info
        $thisID =~ s/\..*//;                 # Remove the dot and extension
        if($thisID =~ /[^0-9a-f]+/i)
        {
            displayMsg(90, "ERROR: 20F1D9 \$thisID is not a valid Hex Number: $thisID\n");
            return "";  # Not a valid ID
        }else{
            my $fileID = hex( $thisID );      # Convert thisID from Hex back to decimal
            $thisFile = $gblFileArray[$fileID - 1];
            if (!$thisFile) { $thisFile = ""; }

            displayMsg(55, "Sub: getFileID( \$thisInput: $thisInput => $thisFile)\n");
        }
    }

    return $thisFile;
}
############################################################################
# Returns the path on the documented site for the specified fileID
sub getFileNameTwo{
    my $thisInput = shift||'';
    my $thisID = 0;
    displayMsg(99, "getFileNameTwo: (\$thisInput: $thisInput)\n");
    foreach (@gblFileArray)
    {
        if(lc($thisInput) eq lc($gblFileArray[$thisID]) )  # case-insensitive compare
        {
            return $thisID;
        }
        $thisID++;
    }
    return -1;
}

############################################################################
# Returns a nicely formatted date string, for today
# Based on code from:  http://homepage.mac.com/corrp/macsupt/macperl/localtime.html
sub getNiceDate{
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
    my @weekdays = qw(Sunday Monday Tuesday Wednesday Thursday Friday Saturday);
    my @months = ( "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" );
    my @abrevs = ( "", "st", "nd", "rd", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "th", "st", "nd", "rd", "th", "th", "th", "th", "th", "th", "th", "st");
    my $thisYear = 1900 + $year;
    my $retVal = "$weekdays[$wday], $mday$abrevs[$mday] $months[$mon], $thisYear";
    return $retVal;
}
############################################################################
# Parse the data files to get site-wide data
sub getSecondPassData{
    displayMsg(10, "now in sub getSecondPassData\n");

    my $thisFile = shift||'';
    my $thisType    = "";
    my $thisValue   = "";

    unless (open DATAFILE, $thisFile)
    {
        displayMsg(999, "ERROR 20F1CF: Unable to read from $thisFile: $!\n");
        return;
    }
    my @lines = <DATAFILE>;
    foreach (@lines)
    {
        ($thisType, $thisValue) = split(":", $_, 2);
        if($thisValue)                 # Make sure that we have at least some text to match against in the next block
        {
            if($thisType eq "CLASS")
                { push(@gblCLASSlist, $thisValue) }

            if($thisType eq "TAG")
                { push(@gblTAGlist, $thisValue) }

            if($thisType eq "ID")
                { push(@gblIDlist, $thisValue) }

            if($thisType eq "IMG")
                { push(@gblIMGlist, $thisValue) }

            if($thisType eq "HREF")
                { push(@gblHREFlist, $thisValue) }

            if($thisType eq "JS-FILE")
                { push(@gblJSFILElist, $thisValue) }

            if($thisType eq "FORM")
                { push(@gblFORMlist, $thisValue) }

            if($thisType eq "CSS-FILE")
                { push(@gblCSSFILElist, $thisValue) }

            if($thisType eq "FUNC")
                { push(@gblFUNClist, $thisValue) }

            if($thisType eq "ANON")
                { push(@gblANONlist, $thisValue) }

            if($thisType eq "METH")
                { push(@gblMETHlist, $thisValue) }
        }
    }
    close DATAFILE;
}
############################################################################
# Parse the data files to get site-wide data
sub buildDataReportDetail{
    our $thisObject = shift||'';
    $gblCurrentOutput = "";

    # find(\&processDataStore, $gblMainDatFolder, $thisObject);
    find(\&processDataStore, $gblMainDatFolder);
    displayMsg(7, "Sub Complete: buildDataReportDetail(\$thisObject:".$thisObject.")\n");
    return "<UL>\n$gblCurrentOutput\n</UL>\n";
}
############################################################################
# Parse the data files:
sub processDataStore{
    my $thisFile   = $File::Find::name;
    # my $thisMarker = shift||'';
    my $thisMarker = $main::thisObject;

    my @fields;

    displayMsg(20, "About to processDataStore(\"$thisFile\", looking for:\"$thisMarker\")\n");

    if(-d)
    {
        # Nothing to be done, apart from moving on
        displayMsg(10, "processDataStore: Ignoring Folder: ".$thisFile."\n");
    }else{
        unless (open CURRENTFILE, $thisFile)
        {
            displayMsg(999, "processDataStore: Unable to read from $thisFile: $!\n");
            return;
        }
        if (checkDatFileFormat($thisFile) )
        {
            displayMsg(20, "processDataStore: Reading Data File: ".$thisFile."\n");
            while (<CURRENTFILE>)
            {
                chomp;
                if (index($_, $gblFileSignature) != -1)
                {
                    displayMsg(99, "INFO: \$gblFileSignature found in file: $thisFile\n");
                }else{
                    if (checkDatFileFormat($_) )
                    {
                        @fields = split(":", $_, 2);

                        my $tempUnderscore = $_;
                        if(pop @fields eq $thisMarker)
                        {
                            close CURRENTFILE;  # No need to keep searching this DAT file
                            displayMsg(30, "processDataStore found \"$thisMarker\" in dat file:$thisFile \n");
                            $gblCurrentOutput = $gblCurrentOutput.mapDatFileNameToHTMLlink($thisFile);
                            return;
                        }else{
                            displayMsg(10, "processDataStore: \"$thisMarker\" not in:\"$tempUnderscore\" \n");
                        }
                    }
                }
            }
        }else{
            displayMsg(999, "ERROR 200166: Unable to handle internal data file: ".$thisFile."\n");
        }
        close CURRENTFILE;
        return "";
    }
}
############################################################################
# Create a piece of HTML based on the given path
sub mapDatFileNameToHTMLlink{
    my $thisPath = shift||'';
    my $strOutput = "";

    ## Map:  http://dev.calcresult/css/global2.css
    ## To:   /files/CSS/a/a.html   ?

    my $infoLink = getReportFromDat($thisPath );
    my $thisName = getFileFromDat($thisPath );
       $thisName = removeSiteRoot($thisName);
    my $liveLink = $configValues{"baseURL"}.$thisName;
       $thisName =~ s/\//&#x200B;\//g;       # Insert a zero-width-space before every forward slash, so that any line-wrapping occurs in a nice place
       $thisName =~ s/\\/&#x200B;\//g;       # Insert a zero-width-space before every backslash, ditto

    $strOutput  = "<a href=\"$infoLink\" rel='internal'>Info (iv)</a>";
    $strOutput .= " - $thisName - ";
    $strOutput .= "<a href=\"$liveLink\" rel='external'>Live Page</a>";
    return "<li>$strOutput</li>";
}
############################################################################
sub recordThisFile{
    my $idNum = shift || "-1";
    my $fileName = shift || "no mark";  # May be a folder?

    print MAIN_DATA_FILE $idNum.",$fileName\n";
}

############################################################################
sub indexInternalData{
    my $thisFile = shift||'';

    unless (open DATFILE, $thisFile)
    {
        displayMsg(999, "ERROR 200168: Unable to read from file: $thisFile: $!\n");
        return;
    }

    my @lines = <DATFILE>;
    foreach (@lines)
    {
        my $datLine = $_;
        my $item;
        my $new = 1;

        if (index($datLine, $gblFileSignature) != -1)
        {
            displayMsg(10, "INFO: \$gblFileSignature found in file: $thisFile\n");
        }else{
            foreach $item(@gblResourceList)
            {
                # Unlikely that anything that we compare is case-sensitive
                # MJB ToDo: make the next comparison case-sensitive for anything that needs it:
                if(lc($datLine) eq lc($item) )
                {
                    $new = 0;
                    last;
                }
            }
            if($new)
            {
                push(@gblResourceList, $datLine);
            }
        }
    }
    close DATFILE;
}
############################################################################
sub finaliseInternalData{
    my $resourceCounter = 0;
    my $outFileSpec = $configValues{"reportBase"}."/lists/";

    unless (open RESOURCE_FILE, ">$gblResourceListSpec")
    {
        displayMsg(999, "ERROR 20F1CD: Unable to write to file: $outFileSpec: $!\n");
        return;
    }
    print RESOURCE_FILE $gblFileSignature;

    foreach (@gblResourceList)
    {
        if($_){
            if ($_ =~ /^\s*$/) {
                # String contains 0 or more white-space character and nothing else
                # So just ignore it
                displayMsg(999, "WARN: finaliseInternalData() - \$_ contains only whitespace. \n");
            }else{
                if (index($_, "\n") != -1){
                    print RESOURCE_FILE $resourceCounter.",$_";
                }else{
                    print RESOURCE_FILE $resourceCounter.",$_\n";
                }
                $resourceCounter++;
            }
        }
    }
    close RESOURCE_FILE;
}
############################################################################
# Produces an HTML list of filenames
sub getListOfFilesAsHTML{
  my $thisDir = shift || '.';
  my $HTMLout = "";

  opendir my $dh, $thisDir or displayMsg(999, "WARNING getListOfFilesAsHTML(): opendir '$thisDir' - $!");
  my @files = readdir $dh;
  closedir $dh;

  $HTMLout .= "<UL>";
  foreach (@files){
      if($_){
          $HTMLout .= "<li>".$_."</li>";
      }
  }
  $HTMLout .= "</UL>";

  return $HTMLout;
}

